
# 5. 动态规划

## 5.1 算法策略

动态规划是将复杂问题分解成为小问题求解的策略，与分治算法不同，分治要求各个子问题是相互独立的，但是动态规划的各个子问题是相互关联的

因此动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，这种情况下，分治法会做出很多不必要的工作，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到了一致的问题，从表格中获取即可，所以无需求解每一个子子问题。

## 5.2 适用场景

用于求解最优解问题，如从面额不定的100个硬币中任意选取多个凑成10元，怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够10元。

这个问题可以分成一个个子问题——每次选取硬币，每个子问题又有公共子子问题——选取硬币，子问题之间互相关联——已选取的硬币总金额不能超过10元，边界条件就是最终选取的硬币总金额10元。

## 5.3 解题策略

1. 定义子问题
2. 实现需要反复执行解决的子子问题部分
3. 识别并求解出边界条件

## 5.4 例子——爬楼梯问题

* 爬楼梯问题：需要n阶才能够到达楼顶，每次可以爬1-2个台阶，有多少种不同的方法可以爬到楼顶
* 背包问题：给出一些资源（总量+价值），给定一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的前提下，装入更多的价值
* 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种方案
* 图的全源最短路径：找到从顶点u到顶点v的最短路径
* 最长公共子序列：找出一组序列的最长公共子序列

以爬楼梯问题为例：

### 第一步：定义子问题

用dp[n]来表示迈过第n级台阶的方案数，由于最后一步可能迈两个台阶，也有可能只迈一个台阶，因此第n级台阶的方案数等于第n-1级台阶的方案数加上第n-2级台阶的方案数

### 第二步：实现需要反复执行解决的子子问题部分

```java
dp[n] = dp[n-1] + dp[n-2]
```

### 第三步：识别并求解出边界条件

```java
// 如果台阶数为0，也算是1种
dp[0] = 1
// 台阶数为1，也只有一种方案
dp[1] = 1
```

### 第四步：翻译为代码

```java
int climbStairs(int n){
    int[] dp = [1, 1];
    for(int i = 2; i<= n; i++){
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n];
}
```

这种情况下，时间复杂度和空间复杂度都为O(n)，但是实际上我们只需要保留三个变量就可以了，中间变量在循环中都会丢弃。

```java
int climbStairs(int n){
    int dp0 = 1, dp1 = 1, res = 1;
    for(int i = 2; i<=n; i++){
        res = dp0 + dp1;
        dp1 = res;
        dp0 = dp1;
    }
    return res;
}
```

## 5.5 例子——使用最小花费爬楼梯

数组的每一个索引作为一个阶梯，第i个阶梯对应这一个非负数的体力花费值cost[i]。当你爬上一个阶梯都需要花费对应的体力值，然后可以选择继续爬一个阶梯或者爬两个阶梯。找到达到楼层顶部的最低花费，在开始时，可以选择索引为0或者1的元素作为初始阶梯。

注意到：

* 第i级台阶是第i-1阶台阶的顶部
* 踏上第i级台阶花费cost[i]，如果越过区则不需要花费
* 楼梯的顶部在数组之外

### 第一步：定义子问题

首先子问题是踏上某一个台阶所需要的最低花费，这个最低花费就是到达前两个阶梯的最小体力消耗+本层的体力消耗

如果迈一步踏上第i级台阶，那么就是在第i-1级阶梯的累计体力消耗加上本层消耗：dp[i-1] + cost[i]

如果迈两步踏上第i级台阶，那么就是在第i-2级台阶的累计体力消耗加上本层消耗：dp[i-2] + cost[i]

### 第二步：实现需要反复执行的子子问题部分

```java
dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
```

### 第三步：识别并求出边界条件

刚开始时，如果只有0级台阶，跨过花费为cost[0]，如果有1级台阶，跨过的话有两种情况，分别踏上第0级第1级台阶，直接跨到第一级台阶上。花费min(cost[0] + cost[1], cost[1])

```
dp[0] = cost[0];
dp[1] = Math.min(cost[0] + cost[1], cost[1]);
```

### 第四步：翻译

```java
Integer minCostClimbingStairs(List<Integer> cost){
    List<Integer> dp = new ArrayList<>();
    dp.set(0, cost.get(0));
    dp.set(1, Math.min(cost.get(0) + cost.get(1), cost.get(1)));
    for(int i = 2; i < cost.length(); i++){
       dp.set(i, Math.min(dp[i-2], dp[i-1]) + cost.get(i)); 
    }
    return dp.get(cost.length());
}
```

## 5.5 最大子序和

给定一个整数数组nums，找到一个具有最大和的连续子数组，子数组中最少包含一个元素，返回其最大和。
