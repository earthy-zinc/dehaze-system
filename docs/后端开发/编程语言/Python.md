# Python 练习

## 1. 数据类型

在Python中主要有以下几种数据类型：整数、浮点数、字符串、布尔值、空值

* 整数：Python区别于其他语言的特点是，它允许数字中间以`_`来分割，即把数字写成1_000，也是可以的。
* 浮点数：对于很大的浮点数需要使用科学记数法来表示，把10的n次方写作en。
* 字符串：
	* Python中字符串可以使用单引号或者双引号括起来，字符串内部包含这些字符的话使用转义字符`\`表示。
	* 使用`r' '` 表示法表示字符串，其内部字符是默认不转义的。
	* 使用三个单引号可以表示多行内容，`''' '''`。
* 布尔值：为逻辑判断True和False。
* 空值：使用 `None` 来表示

## 2.变量和常量

**变量**：变量名称必须是大小写英文、数字和下划线`_`的组合，数字不能用于开头。Python的变量本身类型不固定，因此Python是一种动态语言。因此Python在声明并定义变量的时候，变量在内存中本身是不存储数据的，它存储的是指向那个数据的内存地址。

**常量**：Python中用全部大写的变量名表示常量。但是实际上程序并没有规定该常量不能够被改变

## 3. 条件判断



## 4. 集合

### 4.1 list

Python中内置了一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素。

* 定义：使用中括号`[]`来定义一个list。
* 获取元素数量：`len(list)`
* 访问列表中的指定元素：`list[n]`
* 追加元素到末尾：`list.append(new_item)`
* 插入元素到指定位置：`list.insert(position, new_item)`
* 删除元素：删除末尾元素`list.pop()`，删除指定位置元素：`list.pop(position)`
* 替换元素：`list[n]=new_item`

### 4.2 tuple

tuple叫做元组，与列表list类似，使用方法也相同，但是元组一旦初始化就不能修改。没有增删改的方法。

### 4.3 dict

字典（dict）使用键值对的方式存储。

### 4.4 set

set（集合）是一组key的集合，不存储值。但是key值不能重复。里面是不能放入可变对象的。因为放入可变翠香会发生其存储的内容发生变化，出现重复矛盾。

## 5. 函数

### 5.1 函数基础

* 函数名：函数名称其实也相当于一个变量，因此我们可以把一个函数名称，赋给另外一个变量，那么我们就可以使用那一个变量名调用该函数。如：

* ```
	# abs()函数是返回数字的绝对值
	a = abs 
	a(-1)
	```

* 从上述的例子中我们可以看到，abs()为函数的调用，而abs是函数本身。获得函数调用的结果，我们可以把结果赋值给变量。如果把函数本身赋值给变量。那么该变量就指向了一个函数。我们就可以通过该变量来调用函数。因此，函数名也是一个变量，函数名是指向函数的变量。而通常意义的变量是指向数据的，这是他们之间的区别。如果改变了函数名的所指，那么他就不能再调用该函数了。
* 高阶函数：如果一个函数可以接收另一个函数作为参数，那么这种函数就称为高阶函数。

### 5.2 函数式编程

#### 5.2.1 map /

`map(function, iterable)`map函数接收两个参数，一个是函数，一个是可迭代的对象。map函数将第二个参数——可迭代对象的每一个元素，都作用在第一个参数——函数上去。也就是说，每一个元素都被执行了一遍函数。把结果作为一个新的可迭代对象返回。

map传入的第一个参数需要是函数对象本身，而不能是函数的调用。

#### 5.2.2 reduce

reduce函数的作用就是，把一个函数f作用在一个序列上，这个函数f必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1,x2), x3), x4)
```

#### 5.2.3 filter

filter函数用于过滤序列，从序列中删除需要的元素，与map/reduce函数类似，filter函数的第一个参数也是一个函数，而第二个参数是一个序列。返回新的过滤过后的序列

#### 5.2.4 sorted

Python内置的排序函数。他可以接受一个key函数实现自定义的排序。这个key函数会作用域list的每一个元素上，然后排序函数会根据key函数返回的结果进行排序。

sorted(list, key=function, reverse=True)

* list：待排序列表
* key：对list的每一个元素进行修改，根据修改后的做排序的依据
* reverse：是否逆序

#### 5.2.5 返回函数

在一个函数中定义一个内部函数，内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，从而可以继续调用。这种程序结构称为闭包closure

#### 5.2.6 匿名函数

关键字lambda表示匿名函数，匿名函数有一个限制，只能有一个表达式，不需要写return。它的返回值就是表达式的结果。

```python
# 匿名函数
lambda x: x*x
# 等价于函数f(x)
def f(x):
  return x*x
```

#### 5.2.7 装饰器

在代码运行期间动态增加功能的方式，称为装饰器Decorator，装饰器是一个返回函数的高阶函数。接收一个函数，并返回一个函数。使用@把该装饰器放到一个函数的定义处。那么调用这个函数，不仅会运行该函数本身，还会在运行该函数前先运行装饰器。

#### 5.2.8 偏函数

偏函数需要导入functools，然后使用functools.partial作用就是把一个函数的某些参数固定住，返回一个新的函数，那么调用这个新的函数要比原来的函数更简单。

## 6. 高级特性

### 6.1 切片

切片操作就类似于一种动作，让我想要获取集合中某一部分的数据，因此我把这一部分的数据切出来获取。切片的操作很简单。通常情况下在集合中取出某位置n上的元素。方法是`L[n]`。

**正向取出多个元素**： 切片操作可以让我们通过一个语句一次性取出多个元素，在一个集合中取出第n到第m个个元素，方法为`L[n:m]`。

特别的，如果取出的元素索引是从0开始的，还可以省略第一个索引。记作`L[:n]`

**倒数取出多个元素**：我们记作倒数第一个元素索引为-1，那么取出倒数的两个元素的方法就是`L[-2:-1]`

特别的，如果取出的元素索引直到-1截止，还可以省略最后一个索引。记作`L[-n:]`。

**每隔x个元素取出一个元素**：切片可以指定两个冒号，三个整数，前两个整数分别确定取出元素的上下界，第三个整数确定隔几个元素取出一个元素。因此从第n个元素开始，每隔x个元素取出一个元素，到第m个元素截止。记作`L[n : m : x]`

特别的，只用一个冒号可以复制原数组，即省略了第一个元素索引，省略了最后一个元素索引。`L[:]`

### 6.2 迭代

通过for循环来遍历整个集合，这种方法叫做迭代。判断一个对象是否为可迭代对象。之后便可以使用for in循环进行迭代。

### 6.3 列表生成式

即可以通过一条语句生成一个有规律的列表，通常情况下我们会采用循环来生成，但是在Python中，我们可以使用列表生成式，把要生成的元素变量放在前面，后面跟上for循环，在代码执行时，就会生成对应的一串元素。语法如下。

* 简单用法：for循环生成连续数字。`x for x in range(1,10)`生成1-10十个数字。
* 进阶1：if 判断筛选生成的数字。`x for x in range(1,10) if x%2 == 0`生成1-10这十个数字中能被二整除的数字。
* 进阶2：多层for循环生成复合的元素序列。`n+m for n in range(1,10) for m in range(-1,5)`

### 6.4 生成器

列表生成式是在程序运行到该语句时，一次生成完整的列表。会占用很大的内存空间。生成器在循环过程中不断推算出后续的元素，节省内存空间。我们在使用列表生成式生成列表后，打印这个列表变量，会立刻展示出该列表中的所有元素。使用生成器，那么就必须通过next()函数在程序运行中指定位置才会运算生成该位置生成的元素。

我们也可以自定义生成器函数。在合适的地方调用yield语句，那么就会从此处输出。我们在使用函数的时候，需要通过next函数来获取yield语句输出的结果，如果遇到return语句，则说明生成器已经运行到了末尾，无法再次生成更多的元素了。

调用生成器函数会新创建一个generator对象，因此我们如果想要通过生成器函数获取接下来的元素，就只能调用一次生成器函数，用一个变量来承接。通过该变量生成下一个元素。

### 6.5 迭代器

可以直接用于for循环的数据类型：

1. 集合数据类型：list、tuple、dict、set、str
2. 生成器

可以被for循环迭代的对象都为可迭代对象。而生成器可以创建一个迭代器Iterator，迭代器可以被next函数调用，并不断返回下一个值。

## 7.  面向对象

### 7.1 类与实例

类是抽象的模板，实例时根据类创建出来的一个个具体的对象。所有的类都继承与object，我们定义一个类，根据该类就可以创建出一个类的实例。每个实例都是独一无二的，在内存中的地址也不相同。

**创建实例**：在创建实例时，我们可以使用一个特殊的初始化方法`__init__`在创建实例时就绑定一些实例应该具有的属性。初始化方法第一个参数是self，表示创建的实例他本身。self指向创建的实例本身，我们可以通过self变量在定义是就为实例指定属性。self变量需要指向的实例对象是Python解释器在运行时动态传入的。

跟普通的函数相比，类只是声明，没有具体的实例化，因此类中方法第一个参数永远是实例变量self。用于在运行中找到对应的实例对象。

#### 私有方法、私有变量

python中的私有方法、私有变量、私有属性都有一个特点，那就是需要在名称前面加上双下划线`__`，私有的属性变量和方法在类的外部无法直接进行访问。

**类中专有方法**

* `__init__`
* `__del__`
* `__repr__`
* `__setitem__`：根据索引设置元素
* `__getitem__`：根据索引获取元素
* `__len__`：判断长度
* `__cmp__`：比较类的两个实例对象的大小
* `__call__`：针对类实例对象本身的调用方法
* `__add__`：应用于运算符重载，定义类的两个实例变量之间的加法运算 +
* `__sub__`：应用于运算符重载，定义类的两个实例变量之间的减法运算 -
* `__mul__`：应用于运算符重载，定义类的两个实例变量之间的乘法运算 *
* `__div__`：应用于运算符重载，定义类的两个实例变量之间的除运算 /
* `__mod__`：应用于运算符重载，定义类的两个实例变量之间的取模运算 mod
* `__pow__`：应用于运算符重载，定义类的两个实例变量之间的乘方运算 pow

#### 类的继承

python中支持类的继承，继承的语法是在定义类的时候，在类名称右边括号中填写其父类，python支持多继承，对于子类未定义的方法的调用，他会在括号中的父类上从左到右进行搜索，直到找不到该方法。

```python
class child(parent1, parent2, ..., parentN):
    <statement>
```

如果父类和子类不再同一个模块中，则需要知名父类所在的模块

#### 方法的重写

在实现了类的继承之后，如果父类的方法无法满足子类的需要，子类可以对该方法进行重写。直接进行重写，在调用方法时会优先调用子类重写的方法

### 7.2 获取对象的信息

**判断对象的类型**：

* 使用type（）函数可以判断对象的类型。对于函数的判断：

	* 自定义函数：types.FunctionType

	* 内建函数：types.BuiltinFunctionType

	* Lambda函数：types.LambdaType

	* 生成器函数：types.GeneratorType

* 使用isinstance（）函数对判断类的继承关系更为方便。他可以用来判断一个对象是否是该类型本身，或者位于该类型的父继承链上。

**获取对象的所有属性和方法：** 使用dir（）函数可以获取对象所有属性和方法，他返回一个包含字符串的list。我们可以进一步判断一个对象是否有某个属性，操作获取或者修改对象的某个属性或者方法。

### 7.3 实例属性和类属性









## 8. 模块化

### 8.1 模块化的基本理解

模块化是为了编写可维护的代码，把很多函数、代码块分组放到不同的文件里。Python中一个py文件就是一个模块。对于模块，为了更好的管理不同的模块，我们又通过按目录组织模块，一个目录称为一个包package，一个包中能存放多个模块。Python对于包的识别方法是，包中必须含有`__init__.py`这个文件，才能被Python识别成为一个包。`__init__.py`这个文件本身就是一个模块，它的模块名就是它所属包的包名。因此可以有多级目录组成多级层次的包结构。

### 8.2 作用域

在一个模块中，我们会定义很多函数和变量，对于只在模块内部使用的变量和函数，我们是通过下划线前缀`_`来实现的。

* **特殊变量：**变量名称前后都带有双下划线的变量是特殊变量，可以被直接引用，但是有特殊用途。
* **私有变量**：变量名称前方带有单下划线或者双下划线的是非公开变量。最好不要直接引用。

对于一些私有函数，也是同样的道理。因此如果看到变量名称前面有下划线，一般都是私有变量或者特殊变量。

## 9. pip

`pip install`命令可以从网上安装python依赖包。语法格式如下：

```python
pip install [option] [package]..
```

* `-c, --constraint <file>`使用给定的约束文件约束版本
* `-r, --requirement <file>`从给定需求文件中安装
* `--no-deps`不安装包的依赖项
* `-e, --editable <path/url>`在可编辑模式下从一个本地路径或者从一个版本控制系统下的URL安装一个项目
* `-t, --target <dir>`将包安装到指定目录。