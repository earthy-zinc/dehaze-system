# Flink 练习

## 概述

Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态的计算。也就是说，一些互联网上的交易、日志、点击流实时数据或者数据库中的数据可以经过Flink处理计算。

### 无界数据流

* 有定义流的开始，但是没有定义流的结束
* 会无休止的产生数据
* 无界数据流产生的数据必须持续处理，即数据被摄取后需要立即处理，我们不能等到所有数据都到达后再处理，因为输入是无限的。

### 有界数据流

* 有定义流的开始，也有定义流的结束
* 有界数据流可以等到读取完所有数据后再进行计算
* 有界数据流的所有数据都可以被排序，所以不需要有序读取
* 有界数据流的处理通常被称为批处理

**有状态的流处理**：把流处理需要的额外数据保存成一个状态，然后针对这条数据进行处理，并且更新状态，这就是所谓的有状态的流处理，状态在内存中优点是速度快，但是可靠性差。状态在分布式系统中的优点是可靠性高，但是速度慢。

### 特点

我们处理数据的目标是低延迟、高吞吐、结果准确、良好的容错性。

Flink的主要特点如下：

* 高吞吐和低延迟，能够每秒处理数百万个事件，毫秒级延迟
* 结果的准确性，Flink提供了事件时间和处理时间，对于乱序的事件流，事件时间仍能保持一致且准确
* 可以连接到常用的外部系统，如kafka、hive、hdfs
* 高可用

### 与Spark比较

## 运行时架构

Flink提交作业和执行任务，需要几个关键的组件：

* 客户端：代码由客户端获取并作转换，之后提交给任务管理器JobManager
* 工作管理器（JobManager）对作业进行中央调度管理，而它获取到要执行的作业后，会进一步处理转换，然后分发任务给众多的任务管理器（TaskManager）
* 任务管理器（TaskManager）数据处理的操作是由任务管理器来做的

### 工作管理器 JobManager

是一个Flink集群中任务管理和调度的核心，是控制应用执行的主进程，也就是说，每一个应用都应该被唯一的JobManager所控制执行，而JobManager又包含三个不同的组件。

#### 工作管家 JobMaster

工作管家 JobMaster是工作管理器中最核心的组件，负责处理单独的作业，所以工作管家 JobMaster和具体的工作是一一对应的，多个工作可以同时运行在一个Flink集群中，每一个工作Job都有一个自己的工作管家JobMaster。在作业提交时，工作管家会先接收到要执行的应用，工作管家会把工作图转换成一个在物理层面的数据流图，这个图被叫做执行图，它包含了所有可以并发执行的任务，工作管家之后会向资源管理器ResourceManager发出请求，申请执行任务必要的资源，一旦它获取到了足够的资源，就会将执行图分发到真正运行他们的TaskManager上，而在运行过程中，工作管家会负责所有需要中央协调的操作。

#### 资源管理器

资源管理器主要负责资源的分配和管理，在Flink集群中只有一个，所谓的资源，主要是指任务管理器TaskManager中的任务槽，任务槽式Flink集群中的资源调配单元，包含了机器用来执行计算的一组CPU和内存资源，每一个任务都需要分配到一个任务槽上执行。

#### 分发器

分发器主要负责提供一个rest接口，用来提交应用，并且负责为每一个新提交的作业启动一个新的JobMaster组件，分发器也会启动一个web ui，用来方便的展示和监控作业的执行信息。

### 任务管理器

任务管理器是Flink中的工作进程，数据流的具体计算是由他来做的，Flink集群中必须至少有一个TaskManager任务管理器，每一个任务管理器都包含了一定数量的任务槽，任务槽是资源调度的最小单位，槽的数量限制了任务管理器能够并行处理的任务数量。启动任务管理器后，它会向资源管理器注册他的任务槽，收到资源管理器的指令之后，任务管理器就会将一个或者多个槽位提供给任务管家调用，任务管家就可以分配任务执行了。

### 核心概念

#### 并行度 Parallelism

当要处理的数据量非常大时，我们可以把一个算子的操作，复制多份到多个节点，数据来了以后就可以到其中任意一个节点执行，这样依赖一个算子任务就被拆分成了多个并行子任务，然后再将它们分发到不同的节点，就实现了真正的并行运算。

再Flink执行过程中，每一个算子可以包含一个或者多个子任务，这些子任务在不同的线程、不同的物理机或者不同的容器中独立的执行。

一个特定算子的子任务的个数称为并行度。这样，包含并行子任务的数据流，就是并行数据流，他需要多个分区来分配并行任务。一般情况下，一个流程序的并行度，就可以认为其所有算子中最大的并行度。

#### 算子链 Operator Chain

一个数据流在算子之间传输数据的形式可以是一对一的直通模式，也可以是打乱的重分区模式。

1. 一对一

这种情况下，数据流维护着分区以及元素的顺序，source算子读取数据之后，可以直接发送给map算子做处理，他们之间不需要重新分区，也不需要调整数据的顺序，这就意味着map算子的子任务看到的元素个数和顺序，跟source算子的子任务产生的完全一样，保证一对一的关系。

2. 重分区

这种模式下，数据流的分区会发生改变。每一个算子的子任务，会根据数据传输的策略，把数据发送到不同的下游目标任务。

3. 合并算子链

并行度相同的一对一的算子操作，可以直接连接在一起形成一个大的任务，这样原来的算子就成为了大任务中的一部分。这样就称为算子链。将一个个算子链接成任务可以减小线程之间切换，基于缓存区的数据交换，减少时延的同时提升吞吐量。

#### 任务槽 Task Slots

flink中每一个任务管理器都是一个JVM进程，它可以启动多个独立的线程并行执行多个子任务。但是任务管理器的资源是有限的，为了控制并发量，我们需要对每个任务运行所占用的资源做出明确的划分。这就是任务槽。

每个任务槽是任务管理器所拥有的计算资源的一个子集。这些计算资源是用来独立执行一个子任务的。

在同一个作业中，不同任务节点的并行子任务，其在时间顺序上可能起着先后的顺序，因此就可以放到同一个槽中进行

**任务槽和并行度的关系**

### 作业提交的流程
