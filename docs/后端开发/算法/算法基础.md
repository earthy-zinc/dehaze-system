# 算法基础

## 枚举

枚举是基于已有知识来猜测答案的一种问题求解策略，不断猜测，从可能的集合中一一尝试，然后再判断题目条件是否成立。在枚举求解中我们要建立简洁的数学模型，想清楚可能的情况，要枚举哪些因素。确定枚举的范围。选择合适的枚举顺序。

### 例题1

一个数组中的数互不相同，求解其中和为0的数对的个数

只要两个数的和为0，那么是不是就符合要求呢。我们可以写出答案。

```c
for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
        if(a[i]+a[j]==0) ansner++;
```

 在这种情况下，我们会发生第一个数等于第二个数的情况。两个数相等时，我们枚举一下每一个数判断是否符合规则。不相等的情况下，如果(a, b)是答案，那么(b,a)也是答案。因此我们只需要统计前一种情况，最后再乘以2就是我们需要的结果。我们要求第一个数出现在靠前的位置。这样就减少了j的枚举范围。减少了时间开销

```c
for(int i=0;i<n;i++)
    for(int j=0;j<i;j++)
        if(a[i]+a[j]==0) ansner++;
```

但是我们不一定需要两个数都枚举出来，枚举其中一个数后，另一个数也就确定了。这是如果我们能够 直接判断那一个数是否存在，就可以省略第二个枚举的时间了。

```c
// 要求数组里的数的绝对值都要小于MAXN
boolean[] met[MAXN * 2];
for( int i = 0; i<n;i++){
    if(met[MAXN - a[i]]) ansner++;
    met[a[i] + MAXN] = true;
}
```

## 模拟

用计算机来模拟题目中要求的操作。在做模拟题之前，要在草纸上尽可能写好实现的流程。在代码中将每个部分模块化，写成函数、结构体或者类。对于一些可能重复用到的概念，可以统一转换，方便处理。调试时就可以分块调试。

### 例题1

1英寸蠕虫位于n英寸深的井底部，它每分钟向上爬u英寸，但是休息一分钟才能向上爬，休息时会滑落d英寸，爬出洞口需要多长时间

```java
public class Solution {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(); // 井深n英寸
        int u = scan.nextInt(); // 上爬u英寸
        int d = scan.nextInt(); // 滑落d英寸
        int time = 0, dist = 0; // 所用时间和当前爬行距离
        while(true){
            dist += u;
            time++;
            if(dist>=n) break;
            dist -= d;
            time++;
        }
        System.out.println("用时"+time);
    }
}
```

## 递归和分治

递归是指在函数定义中使用函数自身的方法，也可以说是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归代码有两个重要特征，结束条件和自我调用。自我调用时在解决子问题，而结束条件定义了最简子问题的答案。

```java
int function(传入的数值){
    if (终止条件) return 最小子问题的解;
    return function(缩小规模);
} 
```

使用递归写出的程序，结构清晰，可读性强，但是递归层数过多就会造成栈溢出的后果。在程序执行中，递归是利用堆栈来实现的，每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，就会减少一层栈帧。

分治是把一个复杂的问题分成两个或者更多相同或相似的子问题，直到最后子问题可以简单的直接求解，然后原问题的解就是子问题解的合并。大概的流程可以看作三步：分解、解决、合并。

1. 分解原来的问题为结构相同的子问题
2. 分解到某个容易求解的边界之后，进行递归求解
3. 将子问题的解合并成原问题的解

分治法能解决的问题一般都有如下的特征：

* 该问题的规模缩小到一定程度就可以很容易的解决
* 该问题可以分解为若干个规模较小的相同问题，也就是说该问题拥有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
* 该问题锁分解出的子问题是相互独立的，子问题之间不包含公共的子问题

递归是一种编程技巧，是一种解决问题的思维方式，而分治算法大都是基于递归的，是解决更具体问题的算法思想。

我们在写递归式，要定义并相信一个函数的作用，不要跳入这个函数中探求更多细节。

### 例题1

给定一个二叉树，他的每一个结点都存放者一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要从叶子节点结束，但是路径方向必须是向下的。

```java
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val){
        this.val = val;
        this.left = null;
        this.right = null;
    }
    // 我们使用递归的方法求解，确信这个函数是我们要递归的函数，并且他的功能是以该结点为根节点的二叉树的路径和是sum的路径总数，该节点可能为空，也可能有两个分支。所以当该节点不为空时，我们算出从当前结点开始，到某个结点结束，路径和等于给定数值的路径总数，然后还有以左右两个孩子结点开始的路径总数

    // 给定一颗二叉树的根节点和需要求出的路径和sum，找到对应的路径总数
    static int pathSum(TreeNode root, int sum){
        if(root == null) return 0;
        return pathSum(root.left, sum) + pathSum(root.right, sum) + count(root, sum);
    }

    // 如果当前节点值为sum，则路径数+1，否则为0，否则就将问题抛给下一层。下一层所需路径数要减去当前结点的值
    // 以当前结点为起始点，找到路径和为sum的所有路径总数
    static int count(TreeNode root, int sum){
        if(root == null) return 0;
        return (root.val == sum)?1:0 + count(root.left, sum - root.val) + count(root.right, sum - root.val);
    }
    public static void main(String[] args) {
        TreeNode root = new TreeNode(10);
        TreeNode node1 = new TreeNode(5);
        TreeNode node2 = new TreeNode(-3);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(2);
        TreeNode node5 = new TreeNode(11);
        TreeNode node6 = new TreeNode(3);
        TreeNode node7 = new TreeNode(-2);
        TreeNode node8 = new TreeNode(1);
        root.left = node1;
        root.right = node2;
        node1.left = node3;
        node1.right = node4;
        node2.right = node5;
        node3.left = node6;
        node3.right = node7;
        node4.right = node8;

        System.out.println("和等于 8 的路径有"+TreeNode.pathSum(root, 3));
    }
}
```

## 贪心

使用计算机模拟一个贪心的人做出决策的过程，每一步总是按照某种指标选取最优的操作。而且只看眼前，并不考虑对以后造成的影响。贪心算法在有最优子结构的问题中最为有效，指的是问题能够分解成子问题来解决，子问题的最优解能够递推到最终问题的最优解。

贪心算法的证明有两种方法，一种是反证法，一种是归纳法。

1. 反证法。如果交换方案中任意两个元素或者相邻的两个元素后。答案并不会变得更好，那么可以推定目前的解已经是最优的解了。
2. 归纳法。先算出边界情况的最优解，然后在证明对于每一个n，F~n+1~ 都可以有F~n~推到出来

最常见的贪心算法有两种。一种是我们将XXX按照某种顺序排序，然后按照某种顺序选择，这种需要先处理后选择。第二种，每次选取XXX中最大或者最小的东西，并且更新XX。这种需要一边处理一边选择。

排序解法：用排序法最常见的情况是输入一个包含几个权值的数组，然后通过排序遍历模拟计算的方法求出最优值。

后悔解法： 思路是无论当前选项是否是最优都要接受，然后进行比较，如果选择之后不是最优了，就反悔，舍弃这个选项，否则就正式接受。

贪心算法与动态规划的区别在于它对每个子问题的解决方案都做出选择，不能会对，动态规划则会保留者之前的运算结果。并且根据以前的结果对当前做出选择。有回退功能

### 例题1

国王邀请n个大臣玩一个游戏。国王、每个大臣在左右手上分别写上一个数。让n个大臣排成一排，国王在最前面。排好队后所有大臣都会获得国王奖赏的进步。每个大臣的金币数是：排在该大臣前面的所有人左手上的数的乘积除他自己右手上的数，向下取整得到结果。要求是获得奖赏最多的大臣，获得的奖赏要尽可能少。

假设排序后的第i个大臣左右手上的数据分别是a~i~, b~i~, 用s表示第i个大臣前面所有人的a~i~ 的乘积。那么第i个大臣的到的奖赏是s/b~i~，第i+1个大臣的到的奖赏是(s * a~i~)/b~i+1~

如果我们此时交换第i个大臣和第i+1个大臣。那么此时的第i个大臣的到的奖赏就是s/b~i+1~第i+1个大臣的到的奖赏就是(s*a~i+1~)/b~i~

如果交换前更优的话。也就是说————交换前两位大臣的奖赏中的最大数小于交换后两位大臣奖赏的最大数。

我们简化这个公式，得到max(b~i+1~, a~i+1~ * b~i~) < max(b~i~, a~i+1~ * b~i+1~)

我们对于初始的随机排序，依次调用邻项交换法进行交换，假定交换后最优就交换，交换前最优就不交换，直到所有结果最优为止。

```java
class Person{
    int a, b;
    Person(int a, int b){
        this.a = a;
        this.b = b;
    }
    // 对于当前第i+1个大臣来说，是否和第i个大臣交换
    static boolean isSwap(int bi){
        return Math.max(b, a*bi) < Math.max(bi, a*b);
    }
    
    public static void main(String[] args){
        ArrayList<Person> persons = new ArrayList<Person>();
        
        
    }
}
```

### 例题2

从0时刻开始，有10^9^个单位时间。在任一单位时间，他都可以选择编号1-N的N项工作中的任意一项完成，1<=N<=10^5^，工作i的截止时间是1<=D~i~<=10^9^，完成后的获利是1<=P~i~<=10^9^，在给定的工作利润和截止时间下，求能获得的利润最大为多少。

我们先假设每一项工作都做，将这些工作按照截止时间排序后入队。判断某一项工作是否要做的时候。如果其截止时间符合条件，则将其于队中报酬最小的元素比较，如果第i项工作的报酬较高，那么ans = ans + a[i].p -q.top()

```java
public class Work implements Comparable<Work>{
    // 工作的截止时间
    long d;
    // 完成后的获利
    long p;

    Work(long d, long p){
        this.d = d;
        this.p = p;
    }

    @Override
    public int compareTo(Work w) {
        return (this.d < w.d )? 1 : 0;
    }
}

class Solution {
    public static void main(String[] args){
        PriorityQueue<Work> pq = new PriorityQueue<>();
        long ans = 0L;
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        Work[] works = new Work[n];
        for(int i=0;i<n;i++){
            works[i].d = scan.nextLong();
            works[i].p = scan.nextLong();
        }
        scan.close();

        Arrays.sort(works);
        for(int i = 0; i<n; i++){
            // 判断截止时间是否符合条件
            if(works[i].d <= pq.size()){
                if(pq.peek()!= null && pq.peek().p < works[i].p){
                    ans += works[i].p - pq.peek().p;
                    pq.poll();
                    pq.add(works[i]);
                }
            }else{
                ans += works[i].p;
                pq.add(works[i]);
            }
        }
        System.out.println(ans);
    }
}
```

## 前缀和

### 例题1：单维度下的前缀和

有N个正整数放到数组A中，现在要求一个新的数组B，新数组的第i个数B[i]是原数组A第0到第i个数的和

* 递推法做题。B[i] = B[i-1] + A[i] , B[0] = A[0]

```java
public Solution {
    public int[] partialSum(int[] a, int n){
        int[] b = new int[n];
        b[0] = a[0];
        for(int i = 1; i < n; i++){
            b[i] = b[i-1] + a[i];
        }
        return b;
    }
    
    public static void main(String[] args){
        
    }
}
```

### 例题2：多维度下的前缀和

比如我们拥有这样一个矩阵：可以视为二维数组

```
1 2 4 3
5 1 2 4
6 3 5 9
```

我们定义一个矩阵这个矩阵的a~x,y~就等于a~i,j~从i等于1加到x，j=1加到y，那这是一个递推求sum的过程,sum~i, j~= sum~i-1,j~ + sum~i, j-1~-SUM~i-1,j-1~ +a~i,j~。

```java
int[][] a,b;
public void main(){
	Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    int m = scan.nextInt();
    for(int i = 1; i<=n; i++){
        for(int j = 1; j<=m; j++){
            a[i][j] = scan.nextInt();
            b[i][j] = b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];
            int ans = 1;
        }
    }
}
```



## 二分

二分查找也称折半搜索，对数搜索，是用来在一个有序数组中查找某一元素的算法。以在一个升序数组中查找一个数为例，他每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程。如果中间元素小于查找的值，那么就只需要从右侧查找。一步步地缩小查找范围。

## 倍增

使线性的处理转化为对数级的处理，大大优化时间复杂度。常用的使区间最大最小值问题（Range Maximum/Minimum Query）的缩写，具体的应用有单调栈、ST表、线段树。还有树上倍增求LCA问题。

## 构造

从形式上看，构造题的答案往往具有某种规律性，使得问题规模迅速增大的时候，仍然有机会比较容易地得到答案。这要求解题时要思考问题规模增长对答案的影响。这种影响是否可以推广。比如说在设计动态规划方法时，要考虑从一个状态到后继状态的转移会造成什么影响。

构造题一个明显的特点是高自由度，一道题的构造方式可以有多种，但是会有一种较为简单的构造方式。形式灵活变化多样。很难找的一个共性问题。

### 例题1

构造一组x, y, z 使得对于给定的n，满足1/x + 1/y + 1/z = 2/n



## 动态规划

动态规划是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划解法耗费的时间会少于普通解法。大致上，要解一个给定的问题，我们需要解其不同部分，即子问题，然后再根据子问题的解得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量，一旦某个子问题的解已经算出，则将其记忆化存储，以便下一次需要同一个子问题解的时候就直接查表。这种作法在重复子问题的数目关于输入规模呈现指数级增长时特别有用。

动态规划应用于子问题重叠的情况：

1. 要去刻画最优解的结构特征
2. 尝试递归的定义最优解的值。也就是从i-1转移到i
3. 计算最优解
4. 利用计算出来的信息构造出最优解

### 例题1：钢条切割

给定一段钢条和不同长度的价格，问如何切割会使总价格最大；

为了求解规模为n的原问题，我们先求解一个形式和原问题一样，但是规模更小的子问题。当完成首次切割后，我们将两段钢条就看成了两个独立钢条切割问题的实例了，也就是我们只需要描述首次切割所产生的问题，接下来就交给切割后产生的那些钢条。我们通过组合相关子问题的最优解，并且在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。

最优的子结构指的是问题的最优解有相关子问题的最优解组合而成，而这些子问题可以独立求解。

动态规划有两种实现方法：

* 带有备忘录的自顶向下方法。记忆化搜索
* 将子问题按照规模排序，类似于递推的自底向上方法。

### 矩阵链乘法

给出n个矩阵的序列，希望计算他们的乘积，问最少需要多少次计算。

### 动态规划的要素

#### 最优子结构

具有最优子结构的问题可以使用动态规划求解。要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择
2. 对于一个给定问题，在其可能的第一步选择中，你需要界定出已经知道那种选择才会得到最优解。现在并不关系这种选择具体是怎么得到的，只是先假定已经知道了这种选择
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何更好地刻画子问题空间
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解，方法是反证法。考虑加入某个子问题的解如不是自身的最优解，那么就可以从原问题的接种用改子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优秀的解，从而与原问题最优解假设矛盾。

要保持子问题的空间尽量的简单，只是在必要的时候才扩展

最优子结构的不同主要体现在两个方面

1. 原问题的最优解涉及了多少个子问题
1. 确定最优解使用哪些子问题时，需要考察多少种选择

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边，如

* 无权最短路径：具有最优子结构性质
* 无权最长路径：不具有，要保证子问题无关，同一个原问题的一个子问题的解不影响其他子问题的解。而求解一个子问题时用到了某些资源会导致这些资源在求解其他子问题时不可用。

子问题的重叠：子问题的空间要足够的小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。

重构最优解：存表并记录最优分割的位置，就不用重新按照代价来重构。

最长公共子序列：子序列允许不连续，每个`c[i][j]`只依赖于`c[i-1][j], c[i][j-1], c[i-1][j-1]`记录左右方案的时候可以不需要额外见表，因为重新选择一遍的时间复杂度也是O(1)的。

最优二叉搜索树：给二叉搜索树的每个结点定义一个权值，问如何安排能够使权值和深度的乘积最小。考虑当一颗子树成为了一个结点的子树时，期望搜索代价有何变化？由于每个节点的深度都增加了1，这颗子树的期望搜索代价的增加值应为所有概率之和。

最长连续不下降子序列：目标是求出给定序列的一个最长连续子序列，满足这个序列中的够一个元素不小于前一个元素。因为是连续的，所以只需要与上一个元素进行比较即可。

```java
int[] a;
public int dp(){
    int now = 1, ans = 1;//now 指示着最长连续序列中元素的个数
    for(int i=2;i<=n;i++){
        if(a[i]>=a[i-1]) now++;
        else now = 1;
        ans = max(now, ans);
    }
    return ans;
}
```

最长不下降子序列，这种情况不需要子序列连续了。

```java
int[] a, d;
public int dp(){
    d[1] = 1;
    int ans = 1;
    for(int i = 2; i<=n; i++){
        for(int j = 1; i<i; j++){
			if(a[j]<=a[i]){//前面的大于等于后面的
                d[i] = max(d[i], d[j]+1);
            	ans = max(ans, d[i]);
            }
        }
    }
    return ans;
}
```



## 搜索

### DFS搜索

把正整数n分解为小于等于m个不同的正整数，排在后面的数必须大于等于前面的数，输出所有方案。

我们可以将要搜索的目标分成若干层，每层基于前几层的状态进行决策，直到达到目标状态。

```java
class Solution{
    int m;
    int[] arr = new int[103];
    /* n在初始时记录的是正整数n本身，随着程序的递归，在进行到第i层时，n表示的是后面所有的正整数之和，作法是将之前已经确定的分解得到的正整数减去。i表示第i层，a表示前一层的正整数。
    */
    void dfs(int n, int i, int a){
        //这一步主要是在计算结束之后输出所有的正整数值
        if(n==0){
            for(int j = 1; j<=i-1;++j){
                System.out.println(arr[j]);
            }
        }
        if(i<=m){
            fo
        }
    }
}
```





# 数学

## 符号

1. 整除：x | y 表示x整除y，即x是y的因数。
2. 取模：x mod y，表示x除以y得到的余数。
3. 互质：x ⟂ y ，表示x和y是互质的。
4. 最大公约数（greatest common divider）：gcd(x,y)
5. 最小公倍数（least common multiple）：lcm(x, y)
