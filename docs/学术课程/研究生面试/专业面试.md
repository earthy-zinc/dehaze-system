## 专业（综合）面试

### 一、数据结构相关

#### 1.数据结构概论

##### 1）时间复杂度和空间复杂度

频度是一个语句在算法中被重复执行的次数，算法中所有语句执行的频度之和称为T(N)，而时间复杂度和T(N)是通数量级的

##### 2）数据的存储结构

分为顺序存储、链式存储、索引存储、散列存储

##### 3）循环和递归

循环结构简单，但它不能解决所有问题，有些使用递归更好。递归调用次数过多四会增加额外的堆栈处理，有可能产生堆栈溢出的情况。

##### 4）贪心算法、动态规划、分治法

* 贪心算法做出在当前看来最好的结果，他不从整体上考虑，求的是局部最优解。
* 动态规划是把问题分解成子问题，前一个子问题的解会对后一个子问题的解产生一定的影响。在求解子问题的过程中保留最优解，丢弃其他解。从而一步一步找到全局最优解。
* 分治法将原问题划分为n个规模较小而结构与原问题相似的子问题，递归的解决这些子问题，然后再合并其结果，得到问题的解。

#### 2.线性表

##### 1）顺序表和链表的区别和联系

1. 顺序表可以顺序读取，也可以随机读取。而链表只能顺序读取
2. 顺序表逻辑上相邻的元素，其物理上也相邻。链式存储逻辑上相邻，物理位置不一定在一起
3. 按值查找，无序的顺序表和链表时间复杂度相同，O(N)。有序顺序表采用折半查找时间复杂度O(LOGN)。按序号查找，顺序表支持随机访问，但是插入和删除操作平均需要移动半个表长的元素。链表不能随机访问牡丹石对于指定结点的插入删除，只需要使用相关结点的指针域。
4. 顺序表在静态空间分配上，空间已满则不能扩充。动态分配则需要移动大量元素，导致操作效率太低。链式结点这只在需要是分配即可。

#### 3.栈和队列

##### 1）栈和队列的区别

略

#### 4.串

略

#### 5.树、二叉树

##### 1）线索二叉树

对于N个节点的二叉树，在二叉链存储结构中有N+1个空链域，利用这些空链域存放遍历次序下该节点的前驱结点和后继结点指针。这些指针称为线索，加上线索的二叉树称为线索二叉树。

##### 2）树的存储结构

* 双亲表示法：用连续的空间存储每个结点
* 孩子表示法：结点本身用连续的空间存储，而每个结点的孩子结点则用单链表连接起来
* 孩子兄弟表示法：以二叉链表作为树的存储结构

##### 3）哈夫曼树

在含有n个带权叶结点的二叉树中，带权路径最小的二叉树叫做哈夫曼树

#### 6.图

##### 1）图的存储结构

邻接矩阵法、邻接表法

##### 2）图的遍历算法

* 广度优先搜索：首先访问起始顶点V, 接着由V出发，依次访问V 的各 个未访问过的邻接顶点W1, W2,.... Wn, 然后依次访问W1, W2,...., Wn 的所有未被访问过的邻接顶 点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被 访问过为止。
* 深度优先搜索：访问图中某一起始顶点V, 然后由v 出发，访问与v 邻接且未被访问的任一 顶点W1, 再访问与W1邻接且未被访问的任一顶点W2....…重复上述过程。当不能再继续向下访问 时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索 过程，直至图中所有顶点均被访问过为止。

##### 3）最小生成树

首先是图的生成树这个概念，指的是一个连通图的生成树需要包含图中的所有顶点，但是要包含尽可能少的边。对于带权的连通无向图，最小生成树是图的所有生成树当中权值之和最小的那一个。因此最小生成树可能不止一个。由树的性质可以得到最小生成树的边数等于顶点数减1。

求解最小生成树有两种算法，PRIM算法聚焦于顶点，适合求解顶点少，但是边稠密的图，时间复杂度是顶点数的平方。 KRUSKAL算法，聚焦于边。适合求解边稀疏，顶点较多的图。时间复杂度和边相关。

##### 4）最短路径

图中一个顶点到另一个顶点所经过的边上的权值之和，定义为带权路径长度，而带权路径长度最短的那条路径称为最短路径。

最短路径算法也有两种，分别是Dijkstra算法，prim算法。运用了动态规划的思想，每次保留当前路径上的最优路径长度，并保存记录。从而一步步求解出最短路径长度。Dijkstra算法求解任意一顶点到其余任意一个顶点的最短路径，要求边的权值不能为负权值，时间复杂度为顶点的平方。prim算法，求解每对顶点之间的最短路径。时间复杂度是顶点的立方。

##### 5）拓扑排序

拓扑排序指的是有向无环图顶点组成的序列，

##### 6）关键路径

从源点到汇点的所有路径中，具有最大路径长度的那一条路径，或者说决定整个工期的一系列关键活动，这样的活动组成的路径叫做关键路径。

#### 7.查找

##### 1）对各种查找算法的概括

查找分为静态查找表和动态查找表。静态查找表包括：顺序查找、折半查找、分块查找；动态查找表包括：二叉排序树和平衡二叉树。

1. 顺序查找。从前往后依次查找元素
2. 折半查找。要求查找表为顺序存储结构且有序。
3. 分块查找：把查找表分为若干子表，每个子表的元素都比他后面子表的元素小，即块间有序，每块中最大的关键字构成一张索引表，表中包括每个子表的起始地址。查找时块间使用索引查找，块内使用顺序查找
4. 二叉排序树：在查找时可以动态的插入
5. 平衡二叉树：左右子树高度差不得超过1

##### 2）B树和B+树

略

##### 3）哈希表

哈希表是根据关键字的值直接进行访问的数据结构，把关键码映射到表中的一个位置，从而查找时直接通过散列函数找到该位置。

哈希函数的构造方法有：直接定址法、除留余数法、数字分析法、平方取中法等。

哈希函数解决冲突的方法：开放定址法（线性探查法、二次探查法）、拉链法

#### 8.排序

##### 1）内部排序算法的概括

排序方法分为插入排序、选择排序、交换排序

* 插入排序分为直接插入排序和折半插入排序、希尔排序
  * 直接插入排序：稳定的排序算法。将整个序列分为无序部分和有序部分，每次从无序部分依次选择元素与有序部分比较找到合适的位置、将原来的元素往后移，将元素插入到相应位置上。
  * 折半插入排序：设置三个变量分别指向序列最低处、中间、最高处，待插入元素和中间值比较，如果大于中间值，说明待查找元素至少在序列右边，则设置最低处为中间位下标+1。折半插入排序比较次数相对直接插入要小。
  * 希尔排序：不稳定的算法，将序列按照步长分为若干子序列，对各个子序列直接插入排序，然后逐步缩小步长，直到步长为1。
* 选择排序分为简单选择排序和堆排序，都是不稳定的排序算法
  * 简单选择排序：将序列分为两个部分，每经过一趟就在无序部分中找到一个最小值然后与无序部分第一个元素交换位置。
  * 堆排序：以大顶堆为例，首先建一个初始堆，堆顶元素是最大值，输出堆顶元素，将剩下的元素继续调整成堆，重复此过程。时间复杂度为O(N log N)
  * 建堆操作：以大根堆为例，物理存储上它是一个一维数组，但是在逻辑上，我们将它看作是这样的一颗完全二叉树，最大的元素存放在根节点，她的任意非根节点的值都要小于双亲节点的值。建堆操作是自下而上逐步调整，首先选取最后的一个非叶结点，将其作为根节点，调整这个小的二叉树，使他满足堆的性质，然后依次往前移动这个小二叉树的根节点，调整使他满足堆的性质，直到这个二叉树真正的根节点，那么此时根节点的值就是整个堆中的最大值。建堆操作的时间复杂度为O(n)，之后的堆排序中一共会有n-1（最后一个元素不用再调整了）次的调整堆操作，所以整体时间复杂度是O(nlogn)。在进行调整操作的时候，可能会改变元素的相对位置，即把原来在后面的关键字元素调整到前面。因此是不稳定的排序算法。
* 交换排序分为冒泡排序和快速排序。其中快速排序是不稳定的算法
  * 冒泡排序：以升序为例，每一趟都将元素两两比较，按照前小后大的规则进行交换，每一趟会将一个最小的元素放到序列最前面。如果下一趟没有发生交换那么可以提前结束。
  * 快速排序：在序列中选择一个元素为数轴，将序列分为两部分，数轴左边的元素都比他小，右边的元素都比他大。对这两部分分别递归的进行快速排序。时间复杂度O(N log N)
* 归并排序：有序表两两合并。

### 二、计算机网络相关

#### 1.计算机网络体系结构

##### 1）计算机网络的主要功能

1、硬件资源共享（在网络上利用别的设备对你的资源进行处理存储、输入输出等，节省本机的硬件资源）

2、软件资源共享（方便互联网上的每个用户使用同一软件资源，从而避免软件研制的重复劳动或者数据重复存取）

3、用户之间的信息交换

4、分布式处理（将一个计算机处理不完的繁重任务分解，分配给网络中其他空闲的计算机系统，从而利用这些空闲资源，提高整个系统的利用率）

##### 2）主机之间通信方式

客户服务器模式、对等模式

##### 3）电路交换、报文交换、分组交换的区别

##### 4）计算机网络提供的服务三种分类

1、面向连接服务和无连接服务

在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能够正常的进行，传输结束后释放连接和所占用的资源。因此分为连接建立、数据传输、连接释放三个阶段。

在无连接服务中，通信双方不需要事先建立连接，需要发送数据的时候可以直接发送，把每个带有目的地址的报文分组传输到网络线路上，由网络层选择合适的路线进行传输。是一种不可靠的服务。尽最大努力交付。

2、可靠服务和不可靠服务

可靠服务是指网络本身具有纠错、检错、应答的机制，能够保证数据正确可靠的传输到目的地。而不可靠服务是指网络只是尽量正确可靠的传输，但不保证数据绝对可靠、正确的传送到目的地，是一种尽力而为的服务。对于不可靠的网络，其传输数据的正确性和可靠性要靠用户或应用本身来保障。

3、有应答服务和无应答服务

有应答服务是指接收方在收到数据后就向发送方给出相应的应答，这种应答是由传输系统内部实现的，而不需要用户的参与。文件传输服务是一种有应答的服务。

无应答服务是指接收方收到数据后布自动给出应答，如果需要回应的话，则由高层来实现。

##### 5）计算机网络的模型（协议），分为哪几层？

1、通常来讲我们可以将计算机网络从上到下作用域不同，分为五层：

* **应用层**为特定的应用程序提供数据传输服务，如HTTP,DNS,FTP,SMTP协议，数据单位为报文message
* **传输层**为应用进程提供通用的数据传输服务。主要包括
  * 传输控制协议TCP(Transmission control protocol)提供了面向连接、可靠的数据传输服务。数据单位是报文段segment。
  * 用户数据报协议UDP(User datagram protocol)提供了无连接、尽最大努力交付的数据传输服务。数据单位是用户数据报datagram。
  * 之所以两者共存，是因为他们应用面不同，都有各自的优缺点。TCP主要注重数据完整性，UDP主要注重数据传输的及时性。传输层协议规定的有流量控制、差错控制、服务质量、数据传输管理，是端到端的通信。
* **网络层**为主机之间提供数据传输服务。是点到点的通信。网络层主要负责异构网络的互联、数据分组的路由与转发、对数据在网络中的传输造成的拥塞进行控制。
* **数据链路层**是在更小的范围内为既同一链路内的主机提供数据传输服务。从上往下看，就是把网络层传下来的分组封装成帧。
* **物理层**考虑如何在传输介质上传输数据（比特流）尽可能屏蔽传输介质和通信手段的差异，使高层感受不到这些差异。

2、OSI模型将应用层又进行了细分，增加了表示层和会话层。这两层在五层协议中是留给了应用程序开发者来处理

* 表示层 数据压缩加密以及数据的描述，使应用程序不用再关心各个主机中数据内部格式不同的问题。
* 会话层 管理和建立会话

3、TCP/IP协议将数据链路层和物理层合并为网络接口层。

##### 6）端到端通信和点到点通信的区别

点到点的通信即直接相连的节点之间的通信，它只提供一台机器到另一台机器之间的通信，而不涉及进程或程序。同时点到点通信并不保证数据传输的可靠性，也看不出来源主机和目的主机之间是哪两个进程在通信，这些工作是由传输层完成的。

端到端的通信建立在点到点通信的基础之上，它是由一段段点到点通信信道构成的，是比点到点通信更高层的通信方式，用来完成进程之间的通信。端是指用户程序的端口，端口号标识了应用层不同的进程。

物理层数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。

#### 2.物理层

略

#### 3.数据链路层

##### 1）组帧、帧定界、帧同步、透明传输

数据链路层的单位是帧，在传输数据时首先需要考虑的问题是如何保证帧和帧之间的传输不会混淆，为了在数据传输过程中识别不同的帧，需要确定每个帧的界限，这是由一个帧首部和尾部的控制信息确定的。即**帧定界**。同时需要做出一些规定保证接收方能够从接受到的二进制比特流中分辨出帧的起始和结束，叫做**帧同步**。在数据中要避免出现与帧定界符相同的比特组合，因此需要规定**透明传输**。

这三种问题主要是通过**组帧**来解决的。组帧的方法有：字符记数法、首位定界法、违规编码法。

##### 2）为什么要进行流量控制？

由于接受方和发送方各自工作速率和缓存空间的差异，可能会出现发送方的发送能力大于接收方的接收能力的现象，如果此时不对发送方的发送速率进行限制，那接收方来不及接受的帧会被后面不断发送的帧淹没，造成帧的丢失和出错。

因此进行流量控制的目的是为了限制发送方的数据流量，使其发送速率不能超过接收方的接收能力。这个过程需要通过某种反馈机制来使发送方能够知道，接收方能否跟得上自己。

##### 3）流量控制的常见方式

1、停止-等待流量控制方式

发送方每发送一帧都要等待接收方的应答信号，接下来才能发送下一帧，接收方每接收一帧，都要反馈一个应答信号。如果接收方不返回应答信号，那么发送方就必须一直等待，因此传输效率较低。可以看做发送窗口和接收窗口的大小都为1。

2、滑动窗口流量控制方式

发送方维持一组连续的允许发送的帧的序号，称为发送窗口。接收方为维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小代表在还没有收对方确认消息的情况下还可以发送多少个数据帧。接收端的接收窗口用来控制可以接受哪些数据帧，不可以接受哪些数据帧。

3、后退N帧协议

发送方无需在收到上一个帧的确认就可以开始发送下一帧。发送方可以连续的发送数据帧，当接收方检测出失去顺序的数据帧时，会要求发送方重发最后一个正确接受的信息帧之后所有未被确认的帧。从发送方角度，当发送了N个帧之后，如果发现该N个帧的前一个帧在计时器超时之后接收方仍然没有返回确认，那么就重传该出错帧，以及随后的N个帧。接收方只允许按顺序的接收帧。

后退N帧协议，一方面因为连续发送数据帧而提高了信道的利用率，但是另一方面，重传时又必须把原来已经传送正确的数据帧重传，又使传输的效率降低。发送窗口大小是大于1的，但是接收窗口只有1

4、选择重传协议

选择重传协议中，发送窗口和接收窗口的大小都大于1。为了进一步提高信道的利用率，可以设法只重传出现差错的数据帧或者计时器超时的数据帧，所以接收窗口要能够收下发送序号不连续但仍然处于接收窗口的哪些数据帧，等到缺失的数据帧收到后再一并提交主机。

##### 4）可靠传输的机制

数据链路层的可靠传输通常使用`确认`和`超时重传`两种机制来完成的。

确认是一种无数据的控制帧，这种帧可以使接收方让发送方知道哪些内容被正确的接收了，有些情况下为了提高数据传输效率，会将确认捎带在一个回复帧中，称为捎带确认。超时重传是指发送方在发送某个数据帧之后，就开始一个计时器，在一定时间内如果没有得到发送的数据帧的确认那么就重传该数据帧，直到发送成功为止。

##### 5）介质访问控制

介质访问控制主要是为使用传输介质的每个结点隔离来自同一信道上的其他结点所传送的信号，以便协调活动结点的数据传输。根据所采用的方法，可以将其划分为三类，信道划分介质访问控制、随机介质访问控制、轮询介质访问控制。

* 信道划分介质访问控制：根据传输介质的物理特性。按照频率、时间、波长等进行划分。
* 随机介质访问控制：所有用户根据自己意愿随机发送帧，占用信道的全部速率。但是不可避免会发生帧的碰撞，为了解决这些碰撞，规定了随机访问的一些协议。
  * ALOHA：如果发送方检测到数据帧的冲突，就等待随机的一段时间重发该帧。
  * CSMA：载波侦听就是发送前先侦听信道是否有其他站点正在发送数据。如果有的话暂时不发送，等到信道空闲时在发送。分为三种
    * 1、非持续式：侦听信道是否空闲，如果空闲开始发送，否则等待一段随机的时间再次重复上述动作。
    * 2、1-持续式：侦听信道是否空闲，如果介质忙持续侦听，一旦空闲就立即发送，如果冲突就等待一段随机分布的时间再次重复上述动作。但是这种情况下如果两个以上的站点等待发送数据，一旦介质空闲就会发生冲突。
    * 3、p-持续式：侦听信道如果空闲，则以p的概率发送，1-p的概率延迟一个时间单元发送，如果信道忙，则持续侦听，一旦空闲就重复上述步骤。
  * CSMA/CD：是载波侦听多路访问的改进方案，添加了碰撞检测的功能，碰撞检测是指，边发送边侦听，用来判断是否有其他站点也在同时发送数据。简单概括为先听后发，边听边发，冲突停发，随机重发。
  * CSMA/CA：在无线局域网的环境下，碰撞检测实施起来花费过大，存在隐蔽站点的问题。因此在设计这种协议时，把碰撞检测改为了碰撞避免。尽量降低碰撞发生的概率。采用二进制指数退避算法、预约信道、ACK确认帧、RTS/CTS帧等来实现碰撞避免。
* 轮询介质访问控制：对链路上的主机轮流发放令牌，只有得到令牌的主机才能够发送数据。

##### 6）链路层协议

链路层实现的有链路管理、组帧、流量控制、差错控制、介质访问控制等功能，每个功能都有许多的解决方案。链路层的协议有局域网和广域网的协议，这些协议规定了在数据链路层使用的功能和对应的解决方案。

##### 7）中继器、集线器、网桥、交换机

都是用于互联、扩展局域网的连接设备，但是他们的工作层次和实现的功能都不同

* 中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段，其功能是消除数字信号在传输中造成的失真和衰减，其原理是信号再生。
* 集线器也工作在物理层，相当于一个多接口的中继器，他可以将多个结点连接成一个共享式的局域网。但是任何时刻都只能有一个结点通过公共信道发送数据。
* 网桥工作在数据链路层，可以互联不同的物理层、不同的MAC子层及不同速率的以太网，网桥有过滤帧和存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。
* 交换机工作在数据链路层，是一个多端口的网桥，是交换式局域网的核心设备，允许端口之间建立多个并发连接，实现多个结点并发传输。

#### 4.网络层

##### 1）路由器的主要功能

路由器主要完成两个功能一是路由选择，二是分组转发

* 路由选择：确定数据分组走哪一条路径。根据特定的路由选择协议构造出路由表，同时经常定期的和相邻的路由器交换路由信息而不断的更新和维护路由表。
* 分组转发：处理通过路由器的数据流，关键操作是转发表的查询、然后转发数据、转发队列管理和任务调度等。路由器在这些操作中，将用户的IP数据报从合适的端口中转发出去。路由表根据路由选择算法得出，转发表由路由表得出，转发表的结构应当使整个查找路径的过程最优化。路由表则需要对网络拓扑变化的计算最优化。

##### 2）动态路由算法

* 距离向量算法

所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。所有的结点都必须参加距离向量交换，以保证路由的有效性和一致性。

* 链路状态算法

要求每个参与该算法的节点都具有完全的网络拓扑信息，他们执行下述的两项任务。第一，主动测试所有邻接节点的状态。两个共享一条链接的结点就是相邻结点。第二，定期的将链路状态传播给所有其他结点

* 两者比较

距离向量路由算法中，每个结点仅仅和它直接邻居交谈，为它的邻居提供从自己到网络中所有其他结点的最低费用估计。在链路状态路由算法中，每个结点通过广播的形式与其他所有结点交谈但是仅仅告诉他们与他直接相连的链路的情况。因此，距离向量算法有可能遇到路由环路的情况。

##### 3）路由协议

对于如何进行路由，当前有两大路由选择协议，一是内部网关协议（IGP），二是外部网关协议（EGP）

* 内部网关协议
  * RIP协议（路由信息协议）Routing Information Protocol 是基于距离向量路由选择协议，使用UDP，与相邻路由器交换整个路由表
  * OSPF协议（开放最短路径优先协议），基于链路状态路由算法，使用IP，与全部的路由器交换相邻的结点链路状态
* 外部网关协议
  * BGP协议（边界网关协议），基于路径向量路由选择协议，使用的是TCP，寻找的并非都是最佳路由

##### 4）网络层转发分组的具体流程

1. 从IP数据报首部提取出来目的主机的IP地址，得出目标网络的地址
2. 如果目标网络与此路由器直接相连，则把数据报直接交付给目的主机，否则就是间接交付
3. 如果路由表中有目的地址的特定主机路由，则将数据报传送给路由表中所指明的下一跳路由器
4. 如果路由表有到达目的网络的路由，则把数据报传送给路由表指明的下一跳路由器
5. 如果路由表有个默认路由，则传送给默认路由器
6. 都无法实现的话，转发分组出错

在发送到下一跳路由器时，是将下一跳路由器的IP地址转化为MAC地址，将其放到MAC帧首部，在不同网络之间传送数据报的时候，MAC帧的源地址和目的地址都要不断的变化，源IP和目的IP是不变化的，另外，网桥转发帧时，不改变帧的源地址。

##### 5）IP地址和MAC地址

IP地址是网络层使用的地址，是分层级的。IP地址放在IP数据报的首部。

MAC地址是数据链路层使用的地址，是平面式的。MAC地址放在MAC帧的首部。通过数据分黄把IP数据报分组封装为MAC帧之后，数据链路层看不见数据报分组中的IP地址。

在网络中结点之间的转发，数据要解包到网络层，由于路由器的隔离（路由器连接了异构的网络，但是对其他网络的细节并不清楚）网络层转发只能通过使用IP地址完成寻址。寻址时每个路由器依据其路由表选择能到目标网络的下一跳地址。IP分组通过多次路由转发到达目标网络后，改为在目标网络LAN中通过数据链路层的MAC地址以广播的形式寻址。

与IPv4相关的概念：

* IPv4数据单元——IP数据报首部：固定部分是20B
* NAT：实现专用网络地址和公用网络地址之间的相互转换
* 子网划分：采用子网掩码对物理子网再进行一次子网划分
* CIDR：在变长子网掩码下，提供了一种消除传统A\B\C类网络的划分

##### 6）ARP地址解析协议

地址解析协议主要完成IP地址到MAC地址的映射，每个主机都设有ARP高速缓存，用来存放本局域网上各个主机和路由器的IP地址到MAC地址的映射表，称为ARP表

ARP主要用于解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题，如果目的主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把数据分组发送给这个路由器，让这个路由器来把分组转发给下一个网络。

##### 7）DHCP动态主机配置协议

动态主机配置协议常用于给主机动态地配置IP地址，是应用层协议，基于UDP

##### 8）ICMP网际控制报文协议

为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议来让主机或者路由器来报告差错和异常情况，ICMP报文作为IP数据报的数据，加上数据报的首部，组成了数据报发送出去。

#### 5.传输层

##### 1）传输层有哪些功能

* **提供端到端之间的通信**，传输层向它上面的应用层提供通信服务，他属于面向通信部分的最高层，同时也是用户功能的最底层。传输层位于网络层之上，为运行在不同主机上的进程提供逻辑通信，而网络层是提供主机之间的逻辑通信。那么即使网络层协议传输的数据是不可靠的，传输层也同样能为应用层提供可靠的服务。

* **能够对协议进行复用和分用**，发送方的不同应用进程都可以使用同一个传输层协议传送数据，这就对协议进行了**复用**，接收方的传输层在分离报文首部后能够把数据正确的交付给不同的应用进程，叫做协议的**分用**。
* **对收到的报文进行差错检测**，而网络层只对IP数据报的首部进行检查，而不检查数据部分。
* 提供了两种不同的传输协议：**面向连接的TCP和无连接的UDP**，应用程序可以根据其用途选用不同的协议。而网络层无法同时实现有连接和无连接的协议。

##### 2）UDP协议

UDP协议在IP数据报服务之上增加了两个最基本的服务：复用和分用、差错检测。

* UDP无需建立连接，也就没有建立连接的时延，速度相对TCP要快很多
* 无连接状态。TCP需要在端系统中维护连接状态，包括接收和发送缓存，拥塞控制参数的序号、确认号。而UDP没有连接状态，也不跟踪这些参数。
* 分组首部开销小
* 应用层能够更好的控制要发送的数据及发送时间。

##### 3）TCP协议

TCP是在不可靠的IP层之上实现的可靠数据传输协议。主要特点如下：

1. 面向连接
2. 点对点
3. 可靠，保证数据传输误差错、不丢失、不重复且有序
4. 全双工通信，允许通信双方在任何时候发送数据，因此建立有发送缓存和接收缓存
   * 发送缓存：暂时存放发送方准备发送的数据，已发送但未收到确认的数据
   * 接收缓存：暂存按需到达但是未被接收的数据，不按序到达的数据

###### TCP连接的建立要考虑的问题

1. 要是每一方能够确认对方的存在（建立连接的前两部双方就互相确认了）
2. 要允许双方能够协商一些参数（第二步服务器收到客户端发来的请求，第三步客户端收到服务器的回应，可以在这里协商参数）
3. 能够对运输实体资源进行分配

###### 三次握手建立连接

第一步客户机发送连接请求，第二步服务器收到连接请求报文段后，如果同意建立连接，则发回确认报文段，分配TCP缓存和变量。第三步客户端收到确认报文段，还需要给服务器确认，同时分配资源。

成功完成这三步之后，就建立了TCP连接，接下来就可以传送应用层的数据，TCP提供全双工通信。服务端的资源是在第二次握手时分配的，而客户端是在第三次握手时分配的，这就使得服务器容易受到洪泛攻击。

###### 四次握手释放连接

第一步客户机要关闭连接，向服务器发送连接释放报文段，并停止发送数据，关闭TCP连接。客户端不再发送数据，但是服务器还能发送数据。第二步服务器收到连接释放报文段，发出确认收到。第三步服务器如果不再向客户端发送数据，则通知释放连接。第四步，客户端收到连接释放报文段，发出收到确认。服务器收到确认后，连接关闭。等待计时器时间结束，客户端连接关闭。

###### 为什么不采用三次握手释放连接？

保证客户端发送的最后一个确认报文段能够到达服务器，如果客户端不等待这段时间，客户端发送的最后确认报文段丢失，则服务器无法正常关闭。

防止出现已经失效的连接请求报文段。

###### 为什么不采用两次握手建立连接

防止已经失效的连接请求报文段又突然传送回服务器而产生的错误。

##### 5）拥塞控制及其算法

拥塞控制是为了防止过多的数据注入网络，防止网络中的路由器或者链路过载。

与流量控制的区别：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、路由器，以及与降低网络传输性能有关的所有因素。而流量控制往往是指点对点的通信量的控制。

主要有以下四种算法：慢开始、拥塞避免、快重传、快回复。

* 慢开始：在TCP刚连接上的时候，发送端先将拥塞窗口置为1，每收到一个对新报文段的确认后，将拥塞窗口增大1这样逐步增加发送方的拥塞窗口，可以使分组注入网络的速率更加合理。这样的话每经过一个传输轮次，拥塞窗口就会加倍，直到增到慢开始门限阈值。
* 拥塞避免：在拥塞窗口增大到阈值的时候，发生网络拥塞的概率增加，此时使用拥塞避免算法。发送端的拥塞窗口每经历一个往返时延增加增加一个拥塞窗口。当出现一次超时时，阈值变为当前的一半。
* 快重传：当发送方连续收到三个重复的确认报文时，直接重传对方尚未收到的报文段。
* 当发送方收到连续三个重复确认时，执行乘法减小算法，将慢开始门限设置为出现拥塞时发送方的拥塞窗口的一半。

#### 6.应用层

##### 1）DNS域名解析协议

域名解析是把域名映射为IP地址或者把IP地址映射为域名的过程，DNS运行在UDP协议之上，使用53号端口。本地服务器查询域名的方式主要有两种，递归查询和迭代和递归结合查询

##### 2）FTP文件传输协议

允许用户在因特网上存取文件，运行在TCP之上，数据流的控制运行在21号端口，数据连接在20号端口。

##### 3）SMTP和POP3邮局传输协议

电子邮件协议分为SMTP和POP3协议

##### 4）HTTP超文本传输协议

### 三、操作系统相关

#### 1.计算机系统概述

##### 1）操作系统的目标和功能，什么是操作系统

* 操作系统是计算机资源的管理者，管理处理机、存储器、文件、和IO设备
* 操作系统为用户提供使用计算机硬件的接口，有命令接口、程序接口、图形接口
* 操作系统用作扩充机器，将裸机改造成功能更强、使用更方便的机器。

##### 2）操作系统的运行机制

1. 操作系统有内核态和用户态，分别运行内核程序和应用程序。内核程序是应用程序的管理者，管理者可以执行一些特权指令，而被管理程序出于安全的考虑，无法执行这些指令。这些特权指令是指一些IO指令、中断指令、存取用于内存保护的寄存器、送程序状态字到对应寄存器的指令。
2. 操作系统的各种功能分别被设置在了不同的层次上，一些与硬件关联较为紧密的模块，处于最底层，如时钟管理、中断管理、设备驱动等。其次是运行频率较高的程序，如进程管理、存储管理和设备管理。这两部分构成了操作系统的内核，这部分的指令和操作工作在核心态。
3. 内核程序包括以下4个内容
   1. **时钟管理** 时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。其次通过时钟中断的管理，也可以实现进程的切换。在分时操作系统中，采用时间片轮转调度来实现。在实时操作系统中，按截止时间控制运行的实现。在批处理系统中，通过时钟管理来衡量一个作业的运行调度。
   2. **中断机制** 起初是用来提高多道程序运行环境中CPU的利用率。针对外部设备。后来成为了操作系统各项操作的基础。键盘鼠标信息的输入、进程管理和调度、系统功能的调用、设备驱动、文件的访问都依赖于中断机制。但是中断机制只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样做可以减少中断的处理时间，提高系统并行处理的能力。
   3. **原语** 是操作系统底层可以被调用的公共程序，他们各自完成一个规定的动作。一是处于系统的最底层，是最接近硬件的部分。二是运行具有原子性。操作只能一气呵成。三是运行时间短，调用频繁。定义原语直接方法就是先关闭中断，等起所有操作不可分割的完成时再打开中断。
   4. **系统控制的数据结构及处理** 这类数据结构用来登记系统硬件的一些状态信息。如作业控制块、进程控制块、设备控制块等。通常涉及三种操作：
      * 进程管理：进程状态管理、进程的调度和分配、创建及撤销进程控制块
      * 存储器管理：存储器空间分配及回收、内存信息的保护程序、代码对换程序
      * 设备管理：缓冲区管理、设备的分配和回收

##### 3）什么是中断和异常

**中断**是指来自CPU执行指令以外的事件发生，CPU要进行对当前指令暂停执行的操作，转而查看和控制外部事件，也叫做外中断。这类中断通常是发生了与当前指令执行无关的事件。如设备发出的输入输出操作结束的中断、时钟中断。

**异常**是指源自CPU执行指令内部的事件，执行指令错误而产生的异常，如程序的非法操作码、地址越界、算数溢出、缺页异常等

##### 4）什么是系统调用

为了更好管理计算机各种资源，防止应用程序错误操作，这些资源的访问都是由操作系统直接控制的，即操作系统提供系统调用来代替应用程序直接的操作计算机的各项资源。应用程序只需要通过和操作系统交互即可。系统调用是通过中断来实现的。

系统调用把用户从底层的硬件编程中解脱出来；提高了系统的安全性，使用户程序具有可移植性；用户程序调用具体硬件就被抽象的接口所取代。

#### 2.进程管理

##### 1）进程与线程

**进程**是程序运行的一个过程，是系统进行资源分配和调度的一个独立单位。**线程**是操作系统能够进行运算调度的最小单位，是CPU调度和分派的基本单位。它被包含在进程中，是进程中实际运作的单位，一条线程指的是进程中一个单一顺序的控制流，每条线程执行不同的任务。进程有自己的独立地址空间，而线程是共享所属的进程的地址空间。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，和其他线程共享本进程的相关资源如内存空间、IO、CPU。在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需要保存和设置少量的寄存器的内容，并不涉及到存储器方面的操作。因此进程切换的开销大于线程切换的开销。线程之间的通信更为方便，同一进程下的线程共享全局变量等数据，而进程间的通信要复杂一些。多线程程序其中一个线程崩溃，整个程序就崩溃了。而多进程程序一个进程崩溃并不会影响其他进程。

##### 2）进程间的通信方式

* 共享内存。即两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和读取，用来进行通信。
* 无名管道。半双工的通信方式，只能在具有亲缘关系的进程之间通信。
* 有名管道，半双工通信方式，可以在不具有亲缘关系的进程之间通信。它存在磁盘结点，有对应的文件，凡是访问过该文件的进程都可以进行通信。
* 消息队列。是存放消息的链表，存放在内存中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓存区大小受限的缺点。
* 套接字。是网络编程的api，可以通过他在不同机器间的进程进行通信
* 信号。

##### 3）进程调度的算法

* 先来先服务算法
* 最短作业优先
* 优先级调度
* 时间片轮转
* 最高响应比优先
* 多级反馈队列调度算法

##### 4）进程同步

同步：多个进程因为合作而使进程的执行有一定的先后顺序，比如某一个进程需要另一个进程提供消息，在获得消息之前，进程处于阻塞态。

互斥：多个进程在同一时刻只有一个进程能进入临界区。

同步机制的4个原则：

1. 空闲让进：当没有进程处于临界区时，应当允许一个请求进入临界区的进程立即进入
2. 忙着等待：当前已有进程进入临界区，所有希望进入临界区的进程都要等待
3. 有限等待：对要求访问临界资源的进程，该进程应能在有限的时间进入临界区
4. 让权等待：当进程不能进入临界区时，应该释放处理机资源

**为什么需要进程同步？**

进程有时候会和其他进程共享资源，如内存、数据库等，当多个进程同时读写一份共享资源的时候，可能会发生冲突，因此需要避免冲突，即进程同步，多个进程按顺序访问资源。

在进程同步中有两个关键变量，互斥量和信号量。互斥量只有一份，只有拥有互斥对象的进程才能够访问互斥资源。信号量对象可以有多个，保存了最大资源数和当前可用资源数。

##### 5）死锁

1. 死锁：是指两个或两个以上的进程在执行的过程中，因为争夺资源而造成的一种互相等待的现象，如果没有外力的作用，他们彼此都无法正常进行下去。此时称整个系统处于死锁状态。
2. 死锁产生的原因：系统资源不足、进程推进的顺序不当
3. 产生死锁的必要条件：互斥、请求并保持、不剥夺、环路等待
4. 处理死锁的方法：
   1. 预防死锁：设置某些条件，去破坏产生死锁的四个必要条件中的其中一个或几个。
   2. 避免死锁：在资源动态分配的过程中，用某种方法防止系统进入不安全状态，从而避免发生死锁。
   3. 检测死锁：允许系统在运行过程中发生死锁，但是要能及时检测出来并将已发生的死锁清除

##### 6）饥饿

进程等待的时间给进程推进带来明显的影响时就会造成进程饥饿。

#### 3.内存管理

##### 1）内存管理应该具有哪些功能

存储管理的主要任务是为多道程序的运行提供良好的运行环境，方便用户使用存储器，提高存储器的利用率以及从逻辑上扩充存储器

1. 内存的分配和回收
2. 地址变换：将逻辑地址转换为物理地址
3. 扩充内存：借助虚拟存储技术和自动覆盖技术，为用户提供比实际内存空间大的地址空间
4. 存储保护：保证进入内存的各道作业都在自己的存储空间上运行，互不干扰

##### 2）将用户程序变为可在内存中执行的程序

1. 编译：编译程序将用户源代码编译成若干的目标模块
2. 链接：链接程序将编译后形成的一组目标模块以及所需要的库函数链接在一起，形成一个完整的装入模块
3. 装入：装入程序将装入模块装入内存中运行

##### 3）程序的链接方式有哪些

1. 静态链接：在程序运行前，就把各个目标模块以及所需的库链接为一个完整的可执行程序，以后就不再拆开
2. 装入时动态链接
3. 运行时动态链接

##### 4）程序的装入方式有哪些

1. 绝对装入
2. 可重定位的装入
3. 动态运行装入：允许程序运行时在内存中移动位置，装入模块装入到内存后的所有地址都是相对地址，在程序执行时访问到相应指令或数据时，才将要相对地址转换为物理地址。需要依靠硬件地址变换机构

##### 5）覆盖和交换技术



##### 6）内存连续分配管理



#### 4.文件管理

#### 5.输入输出管理

### 四、数据库相关

#### 1）什么是事务？事务有哪些特点？

事务是修改数据库的一组操作，可以对这一组操作一次性的提交，也可以一次性的全部失败回滚。满足原子性、一致性、隔离性、持久性。

* **原子性**是指事务是不可分割的最小单元，其中的所有操作，要么全部提交成功，要么全部失败回滚。
* **一致性**是指数据库在事务执行前后都保持着一致的状态，所有事务在同一时刻对一个数据读取结果都是相同的。
* **隔离性**是指该事务的一组操作在提交之前对其他事务是不可见的。
* **持久性**指提交后修改操作会永远的保存在数据库中。

#### 2）数据库并发操作一致性的问题

宏观上两个事务同时对一条数据进行操作，但由于微观上有先后顺序，因此会出现未能实现预想的操作的结果。如同时修改、读脏数据、读时修改，幻读等，保障并发操作的一致性可以由**封锁**实现

#### 3）封锁

#####　1.封锁力度

事务在操作某对象是对其进行封锁，其他事务就被限制对该对象进行这种操作。MySQL中提供了两种封锁粒度，行级锁和表级锁。应该尽量只锁定需要修改的那部分数据，锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高。但是加锁需要消耗系统资源，增加系统开销。

##### 2.封锁类型

* 读写锁
  * 排他锁，又称写锁。一个事务对数据对象添加了排他锁，就可以对该对象进行读取和更新，这期间其他事务不能对该对象加上任何锁。
  * 共享锁，又称读锁。一个事务对数据对象加了共享锁，可以对A进行读取操作，但是不能更新，加锁期间其他事务也可以对该对象添加共享锁，但是不能加排他锁。
* 意向锁
  * 在同时存在行级锁和表级锁的情况下，加锁操作就需要大量的检测，为了使两者共存，使用了意向锁。
  * 意向锁在原来锁的基础上添加了特殊的表级别的锁，用来表示某事务之后会对表中某行加上排他锁或共享锁。事物在给某数据行加锁时必须先获得意向锁。

##### 3.封锁协议

* 三级封锁协议
* 两段锁协议

#### 4）关系数据库理论

##### 1.函数依赖

* A->B表示A函数决定B，也可以说B函数依赖于A
* 如果{A1,A2,A3 ... An}是关系的一个或多个属性的集合，该集合函数决定了关系的其他所有属性，并且是最小的，那么该集合就称为键码。
* 对于A->B如果能找到A的真子集A'，使得A'->B，那么A->B就是部分函数依赖，否则就是完全函数依赖
* A->B，B->C，则A->C是传递函数依赖

##### 2.异常

不符合范式关系会产生异常，主要有冗余数据，修改异常，删除异常，插入异常。

##### 3.范式

* **第一范式**属性不可分。即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。
* **第二范式**每个非主属性完全函数依赖于键码。
* **第三范式**非主属性不传递依赖与键码，即属性不依赖与其他非主属性
* **巴斯科德范式**在第三范式的基础上，任何非主属性不能对主键子集依赖

#### 5）索引

1. 数据库的**索引**：为了加快查询数据效率，我们可以规定唯一能标识一条数据的项，将其作为键值，又称索引。是一种数据结构，通常是用B+树实现的，也可以使用哈希函数实现。
2. B+树和哈希函数的优缺点。
   1. 两者效率不同。B+树搜索的时间复杂度通常为对数级，哈希函数是常数级。
   2. 两者适用范围不同。B+树有序，因此可适用于部分查找、范围查找、排序和分组。而哈希函数只能单个查找，局限性较大。
3. 索引的优缺点：
   1. 加快了查询数据的效率，减少了所需要扫描数据的条数
   2. 虽然提高了查询效率，但是会降低插入和更新效率，因为这两个操作有可能需要重建索引。
4. 索引的设计与优化原则
   1. **不能过度索引。**索引需要额外的存储空间，会降低写操作的性能。

      * 对于B+树这种数据结构、增删操作会破坏平衡树的平衡性，需要对树进行分裂合并、旋转操作。因此在对表增删改的时候，索引会更新甚至重构，索引列越多，花费的时间越长。
      * 经常需要排列、分组、范围搜索的列适合索引，因为索引有序，就无需再花费额外的时间进行排序了
      * 经常出现在where子句的列、join连接子句的列，类似于搜索操作，也可以创建索引，加快查找效率
      * 对长字符串、文本、字节流，不太适合整个构建索引，消耗空间过大。指定一个前缀长度，既能唯一确定这一行数据，又能够节省索引所需的空间。
   2. 索引适用于中大型的表，对于非常小的表，索引带来的效率提升并不明显，而且会损失一些插入和更新效率。对于特大表，建立和维护索引的代价会随之增加。
   3. 根据实际使用的频率和场景，来决定索引优化的策略。如建立多列索引，先使用选择性强的索引，索引包含想要查询的值。

### 五、软件工程相关

#### 1）什么是软件工程？

软件工程就是指导计算机软件开发和维护的一门学科，它的综合性较强，运用经过时间考验而证明正确的管理技术，经济地开发出高质量的软件并且有效维护，涉及到程序语言，数据库、算法和数据结构、软件开发工具、设计模式等方面。

#### 2）软件的生命周期

#### 3）软件测试的目标

#### 4）软件维护的目标

### 六、编程语言相关

#### 1）c语言

##### 1、数据类型

C语言的数据类型可以分为以下几种

* **基本类型**，是算数类型。整数类型和浮点类型，常用的整数类型有char,short,int,long，分别占用存储空间1字节、2字节、4字节、4字节，其中每个字节占8比特。浮点类型有float,double,long double，分别占用存储空间4字节、8字节、16字节。
* **枚举类型**，是算数类型。定义在程序中只能赋予一定离散值的变量
* **void类型**，表示空，通常用于函数返回值为空，或者函数参数为空，指针指向 void指的是对象的地址，而不是类型，他可以转换为任何数据类型。
* **派生类型**，包括指针、数组、结构、共用体、函数类型

##### 2、变量与常量

变量：

* 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的。

* 定义与声明：变量的声明是向编译器保证变量以指定类型和名称存在，这样编译器就不需要直到变量的完整细节也可以继续进行编译。变量的声明只在编译时有意义。变量的定义就是告诉编译器在何处，如何创建变量的存储。
* 左值和右值：指向内存位置的表达式称为左值表达式，右值是存储在内存中某些地址的数值。

常量：

* 是固定值，在定义后不能修改。常量的类型分为整数常量，浮点常量，字符常量，字符串常量。常量可以用#define 和 const 关键字定义。

* 整数常量：前缀指定基数，0X或0x表示十六进制，0表示八进制，不带前缀默认为十进制。后缀是U,L的组合，U代表无符号整数，L代表长整数。
* 浮点常量：浮点常量由整数部分、小数点、小数部分、指数部分组成。可以使用小数形式指数形式来表示浮点常量。
* 字符常量：单引号中
* 字符串常量：双引号中

#### 2）关于Java语言

##### 1、Java 和 C++的区别?

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是类可以实现多个接口。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载。

##### 2、JRE和JDK的区别

JDK is java development kit, Java开发工具包，提供了Java开发和运行环境

JRE is java runtime environment, Java的运行环境。

##### 3、== 和 equals 的区别

针对 == 符号

对于基本类型：比较值是否相同。

对于引用类型：比较其引用是否相同。类似于c语言指针指向不同的内存地址的两个值，虽然值相同，但是指针所指的地址不同，是两个不同的变量。

针对 equals

本质上为 == 但是String Integer 重写了 equals 方法，将其变为了值比较。但是对于两个值相同的一般对象，两者是不相等的。

##### 4、Java中操作字符串的对象有哪些类？

操作字符串的类有`String`、 ` StringBuffer`、  `StringBuilder `

`String`声明的是不可变对象，然后将指针指向新的`String`对象，而 ` StringBuffer`、  `StringBuilder `可以在原有对象的基础上进行操作，如果要经常改变字符串的内容最好不要使用`String`。

` StringBuffer`是线程安全的，  `StringBuilder `是非线程安全的。

##### List Set Map 之间的区别

![图片](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIOPwPTKJJXaorw1FJMNRKaOeo9tSDgcGQj8vy249ZdF7HIyDTEaa0YtNUM87hPsXV8gLrShy4gjBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

1. List 和 Set 都继承自Collection接口，List 的元素可以重复，而Set Map的元素不可重复

##### get和post请求有哪些区别

1. get参数通过URL传递，而post参数放在请求体中，因此get的请求参数会被完整的保留在浏览器的历史记录里面，而post的参数不会，因此get参数不能用来传递敏感信息。
2. get请求在URL中传送的参数是有长度限制的，参数的数据类型在URL中会被转换为ASCII字符。

#### 3）面向对象编程

##### 1、面向对象的特性有哪些？

封装、继承和多态

- **封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。** 比如说封装可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。**使用封装不仅仅安全，更可以简化操作。**
- **继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。** 继承的缺点：**1）**继承是一种强耦合关系，父类变子类也必须变；**2）**继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。
- **多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。**比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。 **多态的条件**：**1）**继承；**2）**重写；**3）**向上转型。 **多态的好处**：当把不同的子类对象都当作父类类型来看，**可以屏蔽不同子类对象之间的实现差异，**从而写出通用的代码达到通用编程，以适应需求的不断变化。
- **抽象**是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。

##### 2、面向对象和面向过程的区别？

面向过程是**一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程**，即先干啥，后干啥。

面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。



![img](https://pic2.zhimg.com/v2-d20bb427c9c7d3e12fe20c7ff67c3c55_b.jpg)



- **面向过程的缺陷：** 向过程的设计,是**采用置顶而下的设计方式**，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。
- **问题：**1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。

面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出**面向对象**思想。

面向对象是一种基于面向过程的新的编程思想，是**一种站在对象的角度思考问题**的思想，我们把多个功能合理的放到不同对象里，**强调的是具备某些功能的对象。**



![img](https://pic4.zhimg.com/v2-2e96546f251d5b3c269cb6a52f29e2db_b.jpg)



- 面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。

##### 3、模块独立性耦合与内聚

对象是由 *数据* 以及可以对这些数据施加的 *操作* 所组成的统一体，而且对象是以 *数据* 为中心的，*操作* 围绕对其数据所需做的处理来设置，没有无关的操作。因此，对象内部各种元素彼此结合得很紧密。内聚性很强。由于完善对象所需要的东西基本上被封装在对象内部了，对象本身对外界的联系自然就少了很多。因此对象之间的耦合就比较松。

##### 4、对象、类、消息、方法

* 对象是人们要进行研究的任何事务，从最简单的整数到最复杂的飞机都可以看做是对象，可以表示具体的事物，也可以表示抽象的规则、计划或事件
* 类是具有相同或相似性质的对象的抽象形态。对象的定义是类、类的具体化是对象。
* 对象之间进行通信的结构叫做消息。在对象的操作中，当一个消息发送给某个对象时，消息包含接受对象去执行某种操作的信息。发送一条消息至少要包括说明接受消息的对象名、发送方名称等。
* 类中的操作的实现过程叫做方法

##### 5、面向对象分析设计的三个模型

* **对象模型**描述系统的静态结构，包括对象、他们的属性和操作、对象之间的关系。
* 动态模型着重于系统的控制逻辑，考察在任何时候对象及其关系的改变，描述这些涉及时序和改变的状态。动态模型包括状态图和事件跟踪图。
* 功能模型

#### 4）关于spring MVC 的理解

MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。

总结如下：

- 视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。
- 控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。
- 数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。

MVC优缺点

优点

- 多视图共享一个模型，大大提高了代码的可重用性
- MVC 三个模块相互独立，松耦合架构
- 控制器提高了应用程序的灵活性和可配置性
- 有利于软件工程化管理

缺点

- 原理复杂
- 增加了系统结构和实现的复杂性
- 视图对模型数据的低效率访问

### 七、综合问题

#### 1.笔试题汇报

各位老师大家好，下面由我来汇报一下专业课笔试的第1题——医院新冠管理系统。

这个图清晰的显示了五个模块之间的关系，首先用户需要通过登录操作进入到新冠管理系统的主界面，然后在主界面选择希望使用的功能进入到2-5模块，在操作结束后返回主界面提示用户进行下一步操作或者退出系统。

下面我来讲解一下每个模块的实现过程。

##### 登录模块

登录模块负责用户登录等功能。首先是要求用户输入账号名和密码，密码用*号标识，实际上就是不在屏幕上显示用户输入，但是用户每输入一个字符，就往屏幕输出一个星号。用户回车后，将之前输入的字符组成字符串。之后调用string compare字符串比较函数比较字符串是否和规定的一致，如果不一致，则提示用户名密码输入错误，循环执行上述动作。

##### 主界面

主界面负责显示用户界面、处理用户输入是要进行哪一种操作。使用if判断句来判断用户输入，之后根据用户输入来确认进入哪个模块。主界面通过循环将函数主体代码包裹起来，如果用户在一次业务操作后，输入y，函数就会继续循环。实现了可重复操作的效果。该方法在本项目中的其他地方也有应用。之后在讲解模块2-5时就不再说明。

##### 通用文件读写模块

模块2-5的共同点就是需要进行文件读写，我们可以封装与文件读写相关的逻辑，构建一个通用文件读写模块。下面我给老师们展示一下这个流程图，这个流程图就清晰的说明了相关函数之间的关系。具体来讲：

* 读取文件函数从文件中读取数据，将其装入到c++中的数据结构中如c++容器vector。然后将vector返回给其他调用该函数的模块。
* 写入文件模块和读取模块正好相反，将其他函数传入的数据结构逐个写入到文件中。
* 这样做的好处是其他的业务模块获取数据时，只需要调用该文件读写模块中的函数，而无需考虑文件读写的具体细节，做到了函数复用，减少重复编程出错的概率。
* 另外，文件读写函数并不直接指定文件名，而是通过参数传入，这样即使文件名称更改，函数内部不需要对此做出修改。

##### 新增患者记录和新增疫苗接种记录

这两个模块非常相似，都需要进行用户输入，实现中最重要的一点就是如何判断输入数据的有效性。患者信息和疫苗接种记录我使用的是结构体存储，看一下这个图，对结构体的每个属性都建立一个set方法，在这个方法内部通过while循环引导用户输入，同时判断输入有效性，直到用户输入有效的数据则终止循环，这里的方法参数需要是引用类型的，以便把用户输入带出来。

由以上这种思想，在模块中只需要依次调用每个属性的setter方法，获取用户输入，最后将数据存入文件。

##### 统计患者信息

涉及的知识点有排序算法，这里读取文件所有内容到vector向量里面，再利用stl中的排序算法按年龄降序排序。最后依次输入每条数据即可。stl中的排序算法是以快速排序为基础的，因此这里的时间复杂度通常情况下为nlogn

##### 查询患者信息

涉及的知识点有查找算法，这里我是用的是顺序查找，对于每条匹配的数据都将其装入新的vector向量容器中，最后判断新的容器是否为空，不空则输出所有内容，最坏空间复杂度为n时间复杂度也为n。
