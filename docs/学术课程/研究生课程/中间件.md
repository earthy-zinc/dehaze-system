# 中间件
## 汇报
之前我们说过比如支付订单的业务请求，需要多种操作才能完成整个业务，这就需要通过事务进行处理，为了保证事务的原子性、一致性、隔离性、持久性。在单体系统中，我们可以通过数据库锁和Java本地锁解决，而在微服务中，一个业务操作通常要跨多个数据库、服务才能完成。就不能简单通过上述方式解决，这就是为什么我们需要分布式事务。
我们小组的成员讲解了许多分布式事务中间件Seata的原理，为了能够更真实的体验到Seata的作用，我们自己搭建了一套微服务商城项目。这是项目演示地址：商城后台管理系统，大家可以访问体验。需要在校园网内访问。
首先订单支付的整个业务流程是：用户点击了“订单支付”按钮，对当前订单商品支付，第一步需要扣减商品库存（库存-1），第二部需要扣减用户余额，第三步将订单状态更改为已支付。0接下来我们详细看一下后台是如何实现的。
在前端界面中我们点击订单支付按钮就会调用/api/v1/seata/_pay接口，开始payOrder方法，在开启全局事务的条件下，我们会进入Service层的payOrderWithGlobalTransaction订单支付方法，
在service层中，我们首先通过openFeign远程过程调用商品服务扣减库存，然后在调用订单服务支付订单。这个过程中通过注解 GlobalTransactional 开启全局事务
在商品服务内部，并没有继续进行RPC远程过程调用。而在订单服务中，支付订单功能会先调用会员服务修改当前用户的账户余额，然后在修改当前订单状态为已支付，整个过程涉及了三个微服务，不同的数据库；而这三个微服务和数据库都在不同的服务器上，我们的目标是，要么扣减库存、扣减用户账户余额、修改订单支付状态这三个动作全都成功，如果中间出现了任何异常，则需要回滚操作，不能出现库存扣减、账户余额也扣减，但是订单却仍处于未支付状态。因此我们需要借助分布式事务组件Seata开启全局事务。
为了更好的验证开启分布式事务和不开启分布式事务的区别，在代码层面，我们主动添加了一个除数异常，这个异常需要在前端主动开启，开启之后，订单服务在扣减完当前账户余额之后就会抛出算数异常，后续修改订单状态的代码就不会继续执行。此时就会造成整个业务流程状态不一致的现象。但是如果我们开启了全局事务，当订单服务出现异常之后，订单服务会向seata报告事务执行状态。seata就会感知到当前分支事务出现了异常，并查询undo_log表对已执行的操作进行回滚。
这就是全局事务的整个流程。大家可以在项目中自行体验一下在出现异常时开启全局事务和不开启全局的区别。

