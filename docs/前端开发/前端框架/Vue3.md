# Vue3

## 简介

### API风格

#### 选项式API

使用选项式API，我们可以用包含多个选项的对象来描述组件的逻辑，选项所定义的属性都会暴露在函数内部的this上，他会指向当前组件实例。

#### 组合式API

通过组合式API，我们可以使用导入的API函数来描述组件逻辑。在单文件组件中，组合式API通常是会与`<script setup>`搭配使用，这个setup属性是一个标识，告诉vue在编译时进行一些处理，让我们可以更简洁的使用组合式API。这种API风格包含了以下方面的API。

* 响应式API：如ref和reactive，是我们可以直接创建响应式状态、计算属性和侦听器
* 生命周期钩子：让我们可以在组件各个生命周期阶段添加逻辑
* 依赖注入：如provide和inject，是我们在使用响应式API时，利用Vue的依赖注入系统

优点：

* 更好的逻辑复用
* 更灵活的代码组织
* 更好的类型推导
* 更小的生产包体积。`<script setup>`形式书写的组件模板被编译成了一个内联函数，和`<script setup>`中的代码位于统一作用于，就不需要像选项式API需要依赖this上下文对象访问属性，被编译的模板可以直接访问`<script setup>`中定义的变量，无需从实例中代理。这对代码的压缩更为友好。

## 创建Vue应用

每个Vue应用都是通过`createApp`函数创建一个新的应用实例，我们传入的createApp对象实际上是一个组件，每一个应用都需要一个根组件，其他组件将作为其子组件。应用实例必须在调用了`.mount()`方法后才会渲染出来，该方法接受一个容器参数，可以是一个实际的DOM元素或者是一个CSS选择器字符串。应用根组件的内容将会被渲染在容器根元素里面，容器元素自己不会被视为应用的一部分。`.mount()`方法应该始终在整个应用配置和资源注册完成之后被调用。他的返回值是根组件实例而不是应用实例。

应用实例会暴露一个`.config`对象允许我们配置一些应用级选项，例如顶用一个应用级错误处理器。用来捕获所有子组件上的错误。

```vue
app.config.errorHandler = (err) => {
  // 处理错误
}
```

应用实例还提供了一些方法来注册应用范围内可用的资源，比如注册一个组件。注册成功后，该组件在应用的任何地方都是可用的。

应用实例并不只限于一个，createApp允许我们在同一个页面中创建多个共存的Vue应用，而且每一个应用都拥有自己的用于配置和全局资源的作用域。

## 模板语法

在底层，Vue会将模板编译成高度优化的JavaScript代码，结合响应式系统，当应用状态变更时，Vue能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的DOM操作。

### 文本内容插入

* 基本文本插入：最基本的数据绑定形式是文本插值，它使用的是Mustache双大括号语法。双大括号标签会被替换为相应组件实例中属性的值，同时，每次属性更改时他也会同步更新。
* 插入JavaScript表达式：Vue实际上在所有的数据绑定上都支持完整的JavaScript表达式。在Vue模板内，JavaScript表达式可以被用在文本插值中和任何Vue指令属性的值中。每个绑定仅支持单一的表达式，可以在绑定的表达式中使用一个组件暴露的方法，也就是调用函数。模板中的表达式被沙盒化，仅仅能够访问到有限的全局对象列表，该列表会暴露常用的内置全局对象。没有显示包含在列表中的全局对象将不能在模板表达式中访问。

### HTML文本插入

双大括号会将数据解释为文本，而不是HTML，如果想要插入HTML，我们需要使用v-html指令，这里指令由`v-`作为前缀，表明他们是一些由Vue提供的特殊HTML标签属性，这些指令为渲染的DOM应用特殊的响应式行为。

### 绑定HTML属性值

* 常规HTML属性的绑定：双大括号不能再HTML属性中使用，如果想要响应式的绑定一个属性，应该使用v-bind指令。v-bind如果绑定的是null或者undefined，那么对应HTML标签上的该属性会从渲染的元素中移除。由于这个指令非常常用，因此有简写写法`:`开头为`:`的HTML属性是合法的属性名称。

* 对于布尔型的HTML属性，根据其值为true或者false来决定属性是否应该存在于该元素上，disabled属性就是最常见的例子。
* 一次绑定多个HTML属性：通过不带参数的v-bind我们可以将多个属性使用一个`v-bind="objectAttrs"`绑定到单个HTML标签上。

### 指令

指令是带有`v-`前缀的特殊属性，Vue提供了许多内置指令，指令属性的期望值是一个JavaScript表达式，一个指令的任务是在其表达式的值变化时响应式的更新DOM。

#### 指令参数

某些指令会需要一个参数，在指令名称后面通过一个冒号隔开做标识。这个参数通常是HTML原生的属性或者事件名

#### 动态指令参数

指令我们也可以使用动态传入的方式指定。如

```vue
<a v-bind:[attrName]="url">...</a>
```

这里的attrName会作为一个JavaScript表达式被动态执行，计算得到的值会被用作最终的参数。相似的，我们还可以将一个函数绑定到动态的事件名称上。动态参数中的表达式的值应当是一个字符串或者null，null表示移除该绑定。字符串中不应该有空格或引号。

#### 指令修饰符

修饰符是以点`.`开头的特殊后缀，表明指令需要以一些特殊的方式被绑定，例如`.prevent`修饰符会告知v-on指令对出发的事件调用某一函数。

## 响应式编程

### 声明响应式状态

使用reactive()函数创建一个响应式对象或者数组，响应式对象实际上是JavaScript Proxy，其行为表现与一般对象类似，但是不同之处在于Vue能够跟踪对响应式对象属性的访问和更改操作。

reactive()函数能够隐式的从参数中推导类型，但是我们可以使用接口显式标注一个reactive响应式变量的类型。

```typescript
interface Book {
  title: string,
  year?: number
}
const book: Book = reactive({title: 'vue'})
```

当我们更改响应式状态后，DOM文档对象模型会自动更新。但是DOM的更新不是同步的，Vue会缓冲修改的状态直到更新周期的下一个时机。如果要等待一个状态改变后的DOM更新完成后进行一些操作，需要使用nextTick()函数。

在Vue中，状态默认为深层响应式，意味着即使在更改深层次的对象或数组，改动也能够检测到。但是reactive()返回的是原始对象的代理，而不是原始对象本身，也就是说，只有代理对象是响应式的，更改原始对象不会触发更新。对同一个原始对象调用reactive()总是会返回相同的代理对象，而对一个已存在的代理对象调用则会返回其本身。依靠深层响应性，响应式对象内的嵌套对象依然是代理。

但是reactive()仅仅对对象类型是有效的，而对原始类型如string、number、boolean无效。因为Vue响应式是通过属性访问来追踪的，因此必须始终保持对该响应式对象的相同引用。这意味着当我们将响应式对象属性赋值到本地变量、或者通过结构赋值的方式赋值到本地变量，或者将该属性传给一个函数中，会失去响应性。

reactive()的限制是因为JavaScript没有可以作用于所有值类型的引用机制，因此，Vue提供了一个ref()方法允许我们创建可以使用任何值类型的响应式代理ref。ref()会将传入参数的值包装为一个带.value属性的ref对象。一个包含对象类型值的ref可以响应式地替换整个对象。ref被传递给函数或者从一般对象上被结构的时候，不会丢失响应性。

当ref响应式对象作为顶层属性，也就是再模板中使用时，他们会自动解包，不需要再带有.value。

当ref被嵌套在一个响应式对象中，作为属性被访问或者被更改时，他会自动捷豹，因此会表现的和一般属性一样/

## 计算属性

定义计算属性，用于对对象进行计算处理。

```javascript
const bookMessage = computed(() => {
	return author.book.length > 0 ? "Yes":"No";
})
```

定义计算属性，只需要采用computed()方法，方法接受一个getter函数，返回值为一个计算属性响应式对象ref。我们可以通过.value访问计算结果，计算属性在模板中也会自动解包，无需添加.value。计算属性可以自动追踪响应式依赖，当他检测到原始所依赖的对象发生改变时，他自身也会变化。

当然我们通过方法也可以返回一个和计算属性同样的结果，不同的是，计算属性会基于其响应式的依赖被缓存，一个计算属性只有在其依赖的原始对象被更改时才会重新计算，也就是说只要原始对象不改变，无论访问多少次计算属性，都会立即返回先前计算的结果。相比之下方法调用总是会在重新渲染时再次执行函数。

计算属性默认是只读的，只有在特殊场景中，才会需要可写这种属性，我们可以给computed方法提供一个对象，对象中带有get和set方法来创建可写的计算属性

## 类与样式绑定

数据绑定的常见需求是操纵元素的CSS类列表和内联样式，因为class类和style样式都是HTML元素的属性，我们可以向其他属性一样使用v-bind将他们和动态的字符串绑定，但是在处理较为复杂的绑定时，通过拼接生成字符串是麻烦还容易出错的，因此，针对class和style这两种属性，vue提供了特殊增强，除了字符串以外，表达式的值也可以是对象或者数组。

### 绑定HTML元素的class属性
#### 给class属性绑定一个对象

```vue
<template>
<div :class="{active: isActive}"></div>
</template>
```

上述语法表示html中该div元素的class属性中的active子属性存在与否取决于布尔值变量isActive的的真假。

注意`:class(v-bind:class)`指令可以和普通的`class`属性共存。在虚拟DoM渲染后，会将两个属性合并为一个。当class属性中的子属性变化时，class属性列表也会随之更新。

当然绑定的对象不一定需要写成内联的字面量形式，也可以直接给class属性绑定一个响应式对象，响应式对象的格式应和上述的相同，其中对象的属性名应该是css类class的名字，值是一个布尔值，表示该css类是否应该加到当前html元素class属性上。当然绑定的响应式对象可以是计算属性。

#### 绑定数组

我们也可以给class绑定一个数组来渲染多个css的class

```vue
<template>
<div :class="[activeClass, errorClass]"></div>
</template>
<script>
const activeClass = ref("active");
const errorClass = ref("text-danger");
</script>
```

渲染的结果是：

```html
<div class="active text-danger"></div>
```

如果想要在数组中有条件的渲染某个CSS class，我们可以使用三元表达式。

### 组件上绑定class

如果有一个父组件，想要给其子组件传递一些HTML元素上的属性，则需要属性继承

对于只有一个根元素的组件，当我们使用了class属性是，这些属性会被添加到根元素上，并且与该根元素已经存在的class属性合并。

如果组件中存在多个根元素，你需要指定哪一个元素来接受来自父组件传来的class属性，我们可以通过组件上内置的`$attrs`属性来实现指定

子组件MyComponent：

```vue
<template>
  <p :class="$attrs.class">Hi!</p>
  <span>This is a child component</span>
</template>
<script>
  export default {
    name: MyComponent
  }
</script>
```

父组件

```vue
<template>
<MyComponent class="baz"/>
</template>
```

该子组件将被渲染为：

```html
<p class="baz">Hi!</p>
<span>This is a child component</span>
```

### 绑定内联样式






## 条件渲染

## 列表渲染

## 事件处理

## 表单输入绑定

## 生命周期

 每个Vue组件实例在创建时都需要经历一系列初始化步骤，比如设置好数据侦听，编译模板，挂载实例到DOM，以及在数据改变时更新DOM文档，在这个过程中，他也会运行被称为生命周期钩子的函数，让开发者有机会能够在特定阶段运行自己的代码。

### 注册生命周期钩子

比如，onMounted钩子可以用来在组件完成初始渲染，并且创建DOM结点之后运行代码。当调用onMounted时，Vue会自动将回调函数注册到当前正在被初始化的组件实例上，这意味着这些钩子应该会在组件初始化时被同步注册。

## 侦听器

计算属性允许我们声明性地计算一些衍生的值，然是在有些情况下，我们需要在某些状态发生变化时，执行一些事情，如更改DOM，或者根据异步操作的结果修改另一处的状态。

在组合式API中，我们可以使用watch函数在每次响应式状态发生变化时，触发一个回调函数，执行一些事情。

```vue
<script>
	const question = ref("");
  const	answer = ref("question");
  watch(question, async (newQuestion, oldQuestion)=>{
    if(newQuestion.indexOf('?')>-1){
      answer.value = 'Thinking';
    }
  })
</script>
```

### 侦听器侦听数据源的类型

watch侦听器是一个方法，用于侦听他的第一个参数发生的变化，然后调用给定第二个参数传入的方法执行做一些事情。

第一个参数可以是不同类型的数据源，如ref、计算属性、响应式对象、getter函数，多个数据源组成的数组。

但是不能直接侦听响应式对象的属性值，而是需要用一个返回该属性的getter函数

```vue
<script>
	const obj = reactive({ count: 0 });
  watch(
    () => obj.count,
    (count) => {
      console.log(`count is: ${count}`)
    }
)
</script>
```

直接给侦听器watch()传入一个响应式对象，会隐式地创建一个深层侦听器，该回调函数在所有嵌套值变更时都会被出发。相比之下，一个返回响应式对象的getter函数，只有getter函数的返回值返回不同的对象时，才会触发回调。

watch侦听器默认是懒执行的，仅当数据源变化时，才会执行回调。但是在某些场景中，我们希望在创建侦听器后，立即执行一遍回调，

## 模板引用

## 组件

### 组件注册

### props

### 事件

### 组件 v-model

### Attributes

### 插槽

### 依赖注入

### 异步组件

### 内置组件

## 组合式函数

## 自定义指令

## 插件

## 应用规模化

## 服务端渲染

### 总览

默认情况下，Vue组件的职责是在浏览器生成和操作DOM，然而，Vue也支持将组件在服务端直接渲染成HTML字符串，作为服务端响应数据，返回给浏览器，最后在浏览器端，将静态的HTML激活（hydrate）为能够交互的客户端应用。

Server-Side Rendering（服务端渲染）的优势：

* 更快的首屏加载：服务端渲染的HTML无需等到所有的JavaScript都下载并执行完成之后才显示，所以用户将会更快的看到完整渲染的页面。数据获取过程在首次访问时在服务端完成，相比于从客户端获取，会有更快的数据库连接。
* 更快的搜索引擎优化（Search Engine Optimization, SEO）