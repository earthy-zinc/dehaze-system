# Vue3

## 简介

### API风格

#### 选项式API

使用选项式API，我们可以用包含多个选项的对象来描述组件的逻辑，选项所定义的属性都会暴露在函数内部的this上，他会指向当前组件实例。

#### 组合式API

通过组合式API，我们可以使用导入的API函数来描述组件逻辑。在单文件组件中，组合式API通常是会与`<script setup>`搭配使用，这个setup属性是一个标识，告诉vue在编译时进行一些处理，让我们可以更简洁的使用组合式API。这种API风格包含了以下方面的API。

* 响应式API：如ref和reactive，是我们可以直接创建响应式状态、计算属性和侦听器
* 生命周期钩子：让我们可以在组件各个生命周期阶段添加逻辑
* 依赖注入：如provide和inject，是我们在使用响应式API时，利用Vue的依赖注入系统

优点：

* 更好的逻辑复用
* 更灵活的代码组织
* 更好的类型推导
* 更小的生产包体积。`<script setup>`形式书写的组件模板被编译成了一个内联函数，和`<script setup>`中的代码位于统一作用于，就不需要像选项式API需要依赖this上下文对象访问属性，被编译的模板可以直接访问`<script setup>`中定义的变量，无需从实例中代理。这对代码的压缩更为友好。

## 创建Vue应用

每个Vue应用都是通过`createApp`函数创建一个新的应用实例，我们传入的createApp对象实际上是一个组件，每一个应用都需要一个根组件，其他组件将作为其子组件。应用实例必须在调用了`.mount()`方法后才会渲染出来，该方法接受一个容器参数，可以是一个实际的DOM元素或者是一个CSS选择器字符串。应用根组件的内容将会被渲染在容器根元素里面，容器元素自己不会被视为应用的一部分。`.mount()`方法应该始终在整个应用配置和资源注册完成之后被调用。他的返回值是根组件实例而不是应用实例。

应用实例会暴露一个`.config`对象允许我们配置一些应用级选项，例如顶用一个应用级错误处理器。用来捕获所有子组件上的错误。

```vue
app.config.errorHandler = (err) => {
  // 处理错误
}
```

应用实例还提供了一些方法来注册应用范围内可用的资源，比如注册一个组件。注册成功后，该组件在应用的任何地方都是可用的。

应用实例并不只限于一个，createApp允许我们在同一个页面中创建多个共存的Vue应用，而且每一个应用都拥有自己的用于配置和全局资源的作用域。

## 模板语法

在底层，Vue会将模板编译成高度优化的JavaScript代码，结合响应式系统，当应用状态变更时，Vue能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的DOM操作。

### 文本内容插入

* 基本文本插入：最基本的数据绑定形式是文本插值，它使用的是Mustache双大括号语法。双大括号标签会被替换为相应组件实例中属性的值，同时，每次属性更改时他也会同步更新。
* 插入JavaScript表达式：Vue实际上在所有的数据绑定上都支持完整的JavaScript表达式。在Vue模板内，JavaScript表达式可以被用在文本插值中和任何Vue指令属性的值中。每个绑定仅支持单一的表达式，可以在绑定的表达式中使用一个组件暴露的方法，也就是调用函数。模板中的表达式被沙盒化，仅仅能够访问到有限的全局对象列表，该列表会暴露常用的内置全局对象。没有显示包含在列表中的全局对象将不能在模板表达式中访问。

### HTML文本插入

双大括号会将数据解释为文本，而不是HTML，如果想要插入HTML，我们需要使用v-html指令，这里指令由`v-`作为前缀，表明他们是一些由Vue提供的特殊HTML标签属性，这些指令为渲染的DOM应用特殊的响应式行为。

### 绑定HTML属性值

* 常规HTML属性的绑定：双大括号不能再HTML属性中使用，如果想要响应式的绑定一个属性，应该使用v-bind指令。v-bind如果绑定的是null或者undefined，那么对应HTML标签上的该属性会从渲染的元素中移除。由于这个指令非常常用，因此有简写写法`:`开头为`:`的HTML属性是合法的属性名称。

* 对于布尔型的HTML属性，根据其值为true或者false来决定属性是否应该存在于该元素上，disabled属性就是最常见的例子。
* 一次绑定多个HTML属性：通过不带参数的v-bind我们可以将多个属性使用一个`v-bind="objectAttrs"`绑定到单个HTML标签上。

### 指令

指令是带有`v-`前缀的特殊属性，Vue提供了许多内置指令，指令属性的期望值是一个JavaScript表达式，一个指令的任务是在其表达式的值变化时响应式的更新DOM。

#### 指令参数

某些指令会需要一个参数，在指令名称后面通过一个冒号隔开做标识。这个参数通常是HTML原生的属性或者事件名

#### 动态指令参数

指令我们也可以使用动态传入的方式指定。如

```vue
<a v-bind:[attrName]="url">...</a>
```

这里的attrName会作为一个JavaScript表达式被动态执行，计算得到的值会被用作最终的参数。相似的，我们还可以将一个函数绑定到动态的事件名称上。动态参数中的表达式的值应当是一个字符串或者null，null表示移除该绑定。字符串中不应该有空格或引号。

#### 指令修饰符

修饰符是以点`.`开头的特殊后缀，表明指令需要以一些特殊的方式被绑定，例如`.prevent`修饰符会告知v-on指令对出发的事件调用某一函数。

## 响应式编程

### 声明响应式状态

使用reactive()函数创建一个响应式对象或者数组，响应式对象实际上是JavaScript Proxy，其行为表现与一般对象类似，但是不同之处在于Vue能够跟踪对响应式对象属性的访问和更改操作。

reactive()函数能够隐式的从参数中推导类型，但是我们可以使用接口显式标注一个reactive响应式变量的类型。

```typescript
interface Book {
  title: string,
  year?: number
}
const book: Book = reactive({title: 'vue'})
```

当我们更改响应式状态后，DOM文档对象模型会自动更新。但是DOM的更新不是同步的，Vue会缓冲修改的状态直到更新周期的下一个时机。如果要等待一个状态改变后的DOM更新完成后进行一些操作，需要使用nextTick()函数。

在Vue中，状态默认为深层响应式，意味着即使在更改深层次的对象或数组，改动也能够检测到。但是reactive()返回的是原始对象的代理，而不是原始对象本身，也就是说，只有代理对象是响应式的，更改原始对象不会触发更新。对同一个原始对象调用reactive()总是会返回相同的代理对象，而对一个已存在的代理对象调用则会返回其本身。依靠深层响应性，响应式对象内的嵌套对象依然是代理。

但是reactive()仅仅对对象类型是有效的，而对原始类型如string、number、boolean无效。因为Vue响应式是通过属性访问来追踪的，因此必须始终保持对该响应式对象的相同引用。这意味着当我们将响应式对象属性赋值到本地变量、或者通过结构赋值的方式赋值到本地变量，或者将该属性传给一个函数中，会失去响应性。

## 计算属性

## 类与样式绑定

## 条件渲染

## 列表渲染

## 事件处理

## 表单输入绑定

## 生命周期

## 侦听器

## 模板引用

## 组件基础

## 组件注册

## props

## 事件

## 组件 v-model

## Attributes

## 插槽

## 依赖注入

## 异步组件

## 组合式函数

## 自定义指令

## 插件

## 内置组件

## 应用规模化

## 服务端渲染

### 总览

默认情况下，Vue组件的职责是在浏览器生成和操作DOM，然而，Vue也支持将组件在服务端直接渲染成HTML字符串，作为服务端响应数据，返回给浏览器，最后在浏览器端，将静态的HTML激活（hydrate）为能够交互的客户端应用。

Server-Side Rendering（服务端渲染）的优势：

* 更快的首屏加载：服务端渲染的HTML无需等到所有的JavaScript都下载并执行完成之后才显示，所以用户将会更快的看到完整渲染的页面。数据获取过程在首次访问时在服务端完成，相比于从客户端获取，会有更快的数据库连接。
* 更快的搜索引擎优化（Search Engine Optimization, SEO）