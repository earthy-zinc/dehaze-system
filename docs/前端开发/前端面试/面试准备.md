# 面试准备

## 自我介绍

面试官您好，我叫武沛鑫，目前研二，在读于重庆邮电大学，专业是软件工程，希望能够在咱们部门前端岗位实习，平时喜欢自己写技术博客记录文档，也有自己的github主页，目前博客已经积累了大约十万字的内容，并且成功部署到公网服务器上。

我从两个方面谈一下自己能胜任这份工作的地方吧。首先是专业技能方面，我目前熟悉web前端的常用技术栈如HTML、CSS、JavaScript，Vue等，同时我拥有后端JAVA的实际开发经验，了解后端是如何处理前端发来的请求的。最后也对计算机网络、HTTP有一定的了解。

然后是项目方面，最近在做的是一个图像去雾系统，是导师的自然科学基金项目的预期成果之一，我主要负责其中全栈开发的职责，当然重点是前端开发，采用了Vue3和TypeScript等技术。

项目第一个难点主要是需求的分析和页面的设计，一个体验良好的系统需要先分析用户需求，设计良好的代码的架构，否则在开发的过程中就需要进行反复的重构，增加工作量。为此我就调研了市面上类似软件如国外的huggingface，国内阿里云AI开放平台，学习他们如何是设计前端页面，进行API接口的设计的，并从中获得启发，设计出了本系统的基本框架。

第二个难点就是技术层面，我们不希望用户滥用我们提供的各种系统功能，因此需要进行权限划分，由此就引出了用户登录和注册功能、动态菜单和一些其他的功能来对不同用户的权限进行划分，这一点我在简历中详细描述了相关的技术细节。

第三点就是用户体验方面，我们希望用户在使用系统是能够获得良好的用户体验，因此设计了一套响应式布局，来满足电脑端和手机端用户的需求，图像去雾其实主要是涉及到对图片的大量处理，因此我们针对图像上传流程进行优化，从而提高用户体验。

最后为了方便部署和系统迁移，我们采用了docker和nginx进行部署，并通过nginx代理来规避前端请求跨域，提高系统安全性，实现系统的上线稳定运行。

以上就是我的自我介绍，感谢面试官的耐心聆听。

## 项目经历

### 需求分析——这个过程中你是如何学习的

前端方面，主要是分析他们页面设计，去观察他们页面时如何布局的，比如说整个页面左侧是侧边栏，充当了菜单功能。而顶部是标题和用户信息还有一些快捷菜单，而底部则填充了企业的联系方式、版权声明等。然后根据这个来对布局进行拆分。随后我们打开浏览器的开发者窗口，研究他们采用了哪种技术，如果下载的有Vue或者react插件还能够知道他们都用了那些框架，然后大致的观察HTML代码编写细节，CSS样式，发送的网络请求。这样就大致了解了他们前端是如何实现的。

其次是API接口，一些大企业会提供一个开放平台，来供外部的开发者调用他们已经实现好的服务。我们可以就观察他的API是如何命名的、哪些请求使用Get、Post，请求的数据格式是什么样的，返回的数据格式是什么样的，以及针对接口做的加密、限流、错误处理等。我们可以据此窥探其后端是如何设计的。

而我就是从中得到了启发，从而设计出了图像去雾系统的基本框架。

### WebSocket

如果只是保持登录状态的话，其实可以通过setTimeout函数来定时请求后端获取用户状态，但是为了我们的项目后期可拓展性，比如会增加站内信、通知消息等功能。Websocket就是实现这类功能首选，首先呢HTTP是一个无连接、无状态的协议，HTTP 服务器不会保存关于客户的任何信息。用计算机网络的话来说，http就是一种半双工通信技术。而WebSocket协议服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。是HTML5提供的一种浏览器与服务器进行**全双工通讯**的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。

**HTTP协议的缺点**

- **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。

**WebSocket原理**：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。

**WebSocket 特点的如下：**

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据
- 建立在TCP协议之上，服务端的实现比较容易
- 数据格式比较轻量，性能开销小，通信高效
- 没有同源限制，客户端可以与任意服务器通信
- 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL
- 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

### Pinia和浏览器localStorage

Pinia是全局状态管理工具，在页面没有关闭的情况下，我们可以利用Pinia来存储用户信息，让所有的组件共享，但是这些信息只在网页还没有关闭是有效。一旦页面关闭，这些信息就丢失，我们需要将其提前存储在浏览器本地中。如果在没有本地存储的情况下，服务端是无法判断网络中的两个请求是否是同一用户发起的，为了辨别用户身份，我们就需要Cookie存储用户信息。每个Cookie的大小不能超过4kb，但是4kb可能无法容纳角色权限以及其他个性化设置这些信息，为此我们就需要使用localStorage

**LocalStorage的优点：**

- 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
- LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在
- 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带

**LocalStorage的缺点：**

- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
- LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问

### axios二次封装

通过请求、响应拦截器拦截未登录、越权等非法请求。

其中高效的API接口代码结构和模块划分，指的是我们利用多个文件夹来对不同功能的API请求进行分类，其中API接口的分类和后端的Springboot Controller是一致的，其次我们通过typescript的interface接口来对请求和返回的数据类型的定义，通过这种形式，我们可以方便前后端进行联调，同时前端也更容易了解接口请求和返回的格式，进而提高了开发效率和可维护性。

### 菜单展示

静态路由：一些不需要权限的页面我们可以直接写在前端vue-router中，这一类的路由叫做静态路由。

动态路由的获取：首先是在Pinia的store中请求后端获得所有的菜单项，然后根据登录时获得用户的角色，和角色对应的权限，根据其对应的权限和后台所有权限标识进行比对，遍历筛选出当前用户具有的菜单路由，然后将动态路由在登录后添加到vue-router中，这样用户在登录后就能得到符合其权限的菜单了。为了确保针对用户权限的修改能够及时反应在菜单中，我们不会将获取到的动态路由保存在浏览器本地存储中，在用户下一次进入系统，或者刷新页面后会再次请求获得动态路由。

### 响应式布局

整体的页面布局采用的是flex也就是弹性盒子布局，是FlexibleBox的缩写，采用这样的布局能够灵活地调整页面元素的位置。进而我们采用了一些相对单位来调整元素的大小。其中**vw/vh**是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。**百分比**（`%`），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。

针对页面中的字体，主要采用rem单位。 rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。**作用**：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。

我们把项目整体布局按照其功能不同进行拆分，通过组件化管理Vue不同布局页面，成功实现了同时支持电脑端和移动端的显示，用同一套代码实现多种页面布局模式的切换，满足不同用户需求。而其中有一个不能忽视的难点就是布局越多CSS代码也就越庞大，会很难管理，对此我的解决方式进行CSS工程化。

**Flex布局**

任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**。采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。

**响应式网站设计**

（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。

相对单位和绝对单位的优势就是，它能够随着浏览器窗口的调整，动态的改变元素的显示效果。针对页面中的各种元素，我主要采用的是vm/vh/百分比等单位。

**对 CSS 工程化的理解**

CSS 工程化是为了解决以下问题：

1. **宏观设计**：CSS 代码如何组织、如何拆分、模块结构怎样设计？
2. **编码优化**：怎样写出更好的 CSS？
3. **构建**：如何处理我的 CSS，才能让它的打包结果最优？
4. **可维护性**：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

### 图片上传

这个功能具体来说在前端针对图片大小、后缀、MD5进行校验，对于后缀不合要求，大小过大的图片提示用户重新上传，然后计算图片的MD5，在后端的数据库中进行比对，如果有的话，则直接从数据库中查询该图片的链接发送给前端，就避免了重复上传图片，占用带宽。对于多张图片同时上传，通过设置一个合理的并发并发数，在通过一个Promise异步请求，构造一个for循环，同时处理多个图片文件的上传。

上传过程中利用进度条可视化上传流程，具体来说，就是在上传过程中通过一个回调函数，我们会得到一个上传进度的事件，progressEvent，根据这个事件的进展，我们可以构造一个数来确定当前图片的上传情况，通过vue的数据绑定，动态的展示在页面上。

### 部署

为了方便部署和系统迁移，我们采用了docker和nginx进行部署，并通过nginx代理来规避前端请求跨域，提高系统安全性，实现系统的上线稳定运行。

其中跨域问题其实就是浏览器的同源策略造成的。

同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：**协议**、**端口号**、**域名**必须一致。

在开发中，Vue提供了一个开发服务器，可以帮助我们解决浏览器跨域问题。但是在部署环境下，前端被打包成静态页面，我们就需要一个更加专业的服务器来运行这些页面，而nginx就是一个不错的选择。

利用nginx代理这一点也能提高生产环境下系统的安全性，也就是禁止跨域之后能够避免一部分的CSRF **跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

使用docker，方便部署和系统迁移，docker是一个虚拟化的容器，能够对软件依赖的运行环境进行打包，在没有docker之前，我们部署软件就需要先安装其所依赖的所有环境，在不同的系统中，其安装方式、安装流程、环境依赖也不太一样，总之是个非常麻烦的工作。而通过docker，我们可以实现一次把软件依赖的所有运行环境打包，通过一条命令在不同的操作系统中部署，极大的简化了部署流程。

### Django

因为和深度学习相关的AI模型绝大多数都是使用Python编写的，因此对于python代码的调用是必不可少的，最开始我有两种方案，一是使用java来直接调用python代码，发现这种方式很不方便，而且对于错误处理，python后端的掌控力也很差。第二点就是基于python再搭建一套web服务器，向外提供API接口来提供服务，这种方法需要多部署一个后端，但是能够更好地对python代码进行调试和编写。因此我就采用了第二种办法。

### AOP和Redisson

后端的一些重要接口，比如某些post请求会对后端数据库进行修改，如果前端因为网络原因或者其他原因，对该接口重复请求了多次，可能就会造成后端数据不一致、重复写入、重复处理等情况，Spring AOP切面注解，因为AOP面向切面编程的作用就是将分散在各个业务逻辑代码中相同的代码通过**横向切割**的方式抽取到一个独立的模块中。我们可以把防止前端请求重复提交的代码通过AOP在构建时切入到需要的Controller代码中。

而如果真正实现还需要加锁。和Redisson分布式锁，通过加锁并设置过期时间，其实目前来讲分布式锁不是很必要，在部署多个后端，并通过nginx进行负载均衡的时候，这时就需要分布式锁了。因为java的内部锁无法锁住其他的后端。

### 用户权限校验



## 个人技能

### this指向

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向通过四种调用模式来判断。

- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

### 原型链的理解

在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

**特点：**JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。对原型、原型链的理解

### Promise

JavaScript中的异步机制可以分为以下几种：

- **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
- **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
- **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
- **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行

Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

（1）Promise的实例有**三个状态**:

- Pending（进行中）
- Resolved（已完成）
- Rejected（已拒绝）

当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。

（2）Promise的实例有**两个过程**：

- pending -> fulfilled : Resolved（已完成）
- pending -> rejected：Rejected（已拒绝）

注意：一旦从进行状态变成为其他状态就永远不能更改状态了。

**Promise的特点：**

- 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“**承诺**”；
- 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从`pending`变为`fulfilled`，从`pending`变为`rejected`。这时就称为`resolved`（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。

**Promise的缺点：**

- 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
- 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**总结：**

Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

**注意：**在构造 `Promise` 的时候，构造函数内部的代码是立即执行的

### 箭头函数

**1）箭头函数比普通函数更加简洁**

- 如果没有参数，就直接写一个空括号即可
- 如果只有一个参数，可以省去参数的括号
- 如果有多个参数，用逗号分割
- 如果函数体的返回值只有一句，可以省略大括号
- 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：

**（2）箭头函数没有自己的this**

箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

**（3）箭头函数继承来的this指向永远不会改变**

对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

**（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向**

**（5）箭头函数不能作为构造函数使用**

构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。

**（6）箭头函数没有自己的arguments**

箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。

**（7）箭头函数没有prototype**

**（8）箭头函数不能用作Generator函数，不能使用yeild关键字**

### Vue



### HTTP

HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

HTTP协议具有以下**优点**：

- 支持客户端/服务器模式
- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

HTTP协议具有以下**缺点**：

- **无状态：**HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
- **明文传输：**协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
- **不安全**

（1）通信使用明文（不加密），内容可能会被窃听；

（2）不验证通信方的身份，因此有可能遭遇伪装；

（3）无法证明报文的完整性，所以有可能已遭篡改；

### 对 web 标准、可用性、可访问性的理解

可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力

可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性

可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。

## 其他问题

### 为什么选择前端

我在了解前后端整体的开发流程后，就有了这样一个想法，目前互联网已经发展了有十几年的时间了，技术相对来说比较成熟，然而技术是为业务服务的，最终是为人服务的，用户其实对技术并不了解，只重视后端而没有交互性、易用性良好的前端，这样的软件就很难推广下去，相对来说，前端是面向用户的，我更在乎用户体验，希望在技术开发中更贴近用户一些，因此我选择了前端。
