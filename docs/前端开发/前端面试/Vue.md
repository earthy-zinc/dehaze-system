# Vue面试题

## Vue基础

### Vue的基本原理

什么是响应性？

响应性是一种可以使我们声明式的处理变化的编程范式。

在Vue2中，当一个Vue实例创建时，Vue就会遍历其内部data中的属性，用Object.defineProperty将他们转化为getter和setter。在内部则追踪相关依赖，在对应属性被访问和修改的时候通知变化。每个组件实例都定义有相应的watcher（观察者）程序，会在组件渲染过程中将属性记录为依赖，之后当属性的setter被调用时，通知观察者重新计算，从而导致其关联的组件得以更新。

在Vue3中采用的是**Proxy**对象，该对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

### 双向数据绑定的原理



### 使用Object.defineProperty()进行数据劫持的缺点



### MVVM、MVC、MVP的区别

MVVM(Model、View、ViewModel)、MVC(Model、View、Controller)、MVP(Model、View、Presenter)是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。

在以前开发单页面应用时，一个路由页面对应了一个脚本文件，所有页面逻辑都在一个脚本文件中，页面的渲染、数据的获取，用户事件的响应所有的应用逻辑都混合在一起，在项目复杂变得复杂时就会对后期的维护和编写不利。因此人们总结了一套软件架构的设计模式，来简化开发过程中的复杂性。

#### MVC

MVC通过分离模型、视图和控制器的方式来组织代码结构，其中View代表了页面的显示逻辑，Model存储了页面业务数据以及对应的数据操作。View和Model应用了观察者模式，当Model层的数据发生变化时，它会通知有关的View层更新页面。Controller层时View层和Model层之间的纽带。负责用户与应用之间的响应操作，当用户与页面产生交互的时候，控制器就开始通过调用Model层完成对数据的修改，然后Model层通知View层更新。就形成了MVC整个流程。

#### MVVM

MVVM将Model和View和ViewModel分离开，其中：

* Model代表数据模型，数据和业务逻辑都在Model层中定义
* View代表UI试图，负责数据的展示
* ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互

模型和视图之间没有直接关联，主要是通过ViewModel来进行联系，Model和ViewModel之间有双向数据绑定的联系。Model层中的数据变化会触发View层的刷新。View层中由于用户的操作而改变的数据也会同步到Model层中。这种模式实现了Model和View数据的双向同步，进而开发者就无需自己操作DOM而只需要维护数据。

#### MVP

在MVC中，使用观察者模式来实现数据在Model和View之间的绑定，这样View和Model层会耦合在一起，当项目逻辑复杂时会造成代码的混乱，并且可能对代码复用性产生不利影响。而MVP中的P指的时Presenter，能够实现对View和Model的解耦。同时View层接口暴露给了Presenter，可以将Model层变化和View层变化绑定在一起，实现View和Model的同步更新。

### MVVM的优缺点

优点：

* 分离视图和模型。能够降低代码耦合，提高视图和逻辑的重用性。
* 提高可测试性：ViewModel的存在可以帮助开发者更好地编写测试代码
* 自动更新DOM：利用双向数据绑定，数据更新后视图能够自动更新，让开发者从繁重的手动修改DOM中解放

缺点：

* Bug很难调试：因为双向数据绑定，界面异常会难以定位出问题的地方，可能时view层或者model层。
* 在大型模块中，model层会很大。但是也会更占据内存
* 对于大型图形应用，视图状态较多时，ViewModel的构建和维护成本都会很高

### Vue的渲染机制

Vue基于虚拟DOM对页面进行渲染，虚拟DOM将目标所需的UI首先通过数据结构虚拟的表示出来，保存在内存中，然后和真实的DOM保持同步。在第一次渲染时，会有一个渲染器遍历整个虚拟DOM树，并且据此构建真实的DOM树，整个过程被称作挂载。在更新页面的时候，会存在两份虚拟的DOM树，浏览器通过比较他们之间的区别，将其变化的部分应用在真实DOM上。

采用虚拟DOM的优点：

能够让开发者更加灵活地、声明式地创建、检查和组合所需UI结构。在更新时，仅需要



### 模板编译原理

vue中的template模板中的内容是无法被浏览器解析和渲染的， 因为这个不属于浏览器的标准，不是正确的HTML语法，所以需要将模板转换为一个JavaScript函数，让浏览器执行这个函数，然后渲染出对应的HTML元素。这样一个转化的过程，就称为模板编译。整个过程分为三个阶段

1. 解析阶段（parse）：使用大量的正则表达式对template模板中的字符串进行解析，将标签、指令、属性等转化为抽象语法树（Abstract syntax tree）。
2. 优化阶段（optimize）：遍历抽象语法树，找到其中的一些静态节点并标记，方便再页面重绘时进行比较，能够直接跳过这些静态节点优化运行时的性能。
3. 生成阶段（generate）：将抽象语法树转化为渲染函数字符串。

### Vue和React的区别

#### 相似之处

* 都将注意力几种保持在核心库，而将其他功能如路由和状态管理交给其他库来实现
* 都有自己的构建工具
* 都使用了Virtual DOM来提高重绘性能
* 都有Props的概念，允许组件之间信息传递
* 都鼓励组件化应用，将应用拆分为一个个的功能明确的模块，提高复用性

#### 不同之处

* 数据流：vue支持数据双向绑定，react倡导单向数据流
* 虚拟DOM：Vue在渲染过程中，会跟踪每个组件的依赖关系，不需要重新渲染整个组件树。React当应用状态发生改变时，全部子组件都会重新渲染
* 组件化：Vue鼓励写近似于HTML的模板语法，React推荐采用JavaScript语法扩展JSX书写
* 监听数据变化的原理不同：Vue通过getter和setter以及函数的劫持，来知道数据的变化。React默认通过比较引用，如果不进一步优化可能导致大量不必要的虚拟DOM渲染
* 高阶组件：react可以通过高阶组件来扩展，Vue需要通过mixin。
* 构建工具：

## Vue响应式数据处理

### data是一个函数而不是对象



### data中对象属性添加新属性时会发生什么



### data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？



### 计算属性Computed和侦听器Watch和方法Method的区别

#### Computed

* 支持缓存，只有依赖的数据发生了变化，才会重新计算
* 不支持异步，存在异步操作时，就无法监听数据的变化
* 值默认走缓存，计算属性基于响应式依赖进行缓存的。也就是基于data或者父组件传递来的props
* 如果一个属性是由其他属性计算而来，这个属性依赖于其他的属性，会采用computed
* 如果computed属性的属性值是函数，则默认使用get方法，函数的返回值就是属性的属性值。

#### Watch

* 不支持缓存，当数据发生变化时，就会触发相应的操作
* 支持异步监听
* 监听的函数接受两个参数，第一个参数为最新的值，第二个参数时变化之前的值
* 当一个属性发生变化时，就需要执行相应的操作
* 监听的数据必须是data中声明的或者父组件传递来的props中的数据。其中有两个参数比较重要：
  * immediate：组件加载会立即触发回调函数
  * deep：深度监听数据内部的变化，当数据类型比较复杂时使用。但是deep无法监听对象内部的变化
* 当需要数据变化时执行异步或者开销比较大的操作时，使用watch。通过watch可以异步访问一个API，并限制执行频率，在得到最终结果之前设置一个中间状态。

#### Method

不会缓存数据，每次调用都会执行一遍

### 过滤器filter的作用

过滤器是用来过滤数据的，过滤器不会修改数据，而method、computed都是通过修改数据来处理数据的。

* 当需要格式化数据，比如处理时间、价格等数据格式的显示
* 比如后端返回一个 **年月日的日期字符串**，前端需要展示为 **多少天前** 的数据格式，此时就可以用`fliters`过滤器来处理数据。

过滤器filters是一个函数，会将表达式中的值始终当作函数的第一个参数。

### v-if、v-show、v-html原理及区别

* v-if 会调用vue内部的addIfCondition方法，生成虚拟节点vnode时会忽略条件判断为false的节点，在渲染时就会忽略。
* v-show对应的元素会生成虚拟DOM节点vnode，在render函数渲染的时候也会将其渲染会真实的节点，但是会将display属性值设置为不可见
* v-html会先移除节点下的所有节点，然后调用DOM方法，通过addProp添加innerHTML属性。

**进一步分析v-if和v-show的区别**

* 手段：v-if通过动态的向DOM树中添加或删除DOM元素，而v-show则是通过设置DOM元素的display样式来控制元素的显示和隐藏。
* 编译过程：v-if的切换有一个局部编译和卸载的过程，过程中会销毁和创建节点内部的事件监听和子组件。而v-show不包含这些，仅仅时基于样式的改变。
* 编译条件：v-if是惰性的，如果条件为假，则什么也不做，当条件变为真时，才开始局部编译。而v-show在任何条件下都会被编译和缓存。
* 性能消耗：v-if有更高的切换消耗，而v-show有更高的初始渲染消耗
* 使用场景：v-if适合条件改变较少的情况，v-show适合频繁切换的情况。

### v-model是如何实现的





### Vue中封装的数组方法有哪些，其如何实现页面更新



### $nextTick原理（DOM更新）

Vue采用了数据驱动视图的思想，但是在某些情况下仍然需要手动操作DOM，比如当DOM1中数据发生了变化，而DOM2需要从DOM1中获取数据，这是就会发现DOM2中视图并没有更新，这是就需要nextTick。所以在以下情况下会用到nextTick：

* 在数据变化之后执行某个操作，这个操作需要使用随数据变化而变化的DOM结构时，就需要在nextTick回调函数中实现该操作
* vue生命周期，如果在created 也就是vue实例创建时进行DOM操作，也需要放在nextTick中，因为DOM结构还没有真正渲染到页面上。

nextTick本质是对JavaScript执行原理EventLoop的一种应用。利用了如Promise、MutationObserver、等原生JavaScript方法来模拟对应的微任务和宏任务的实现，利用JavaScript中的异步回调任务队列实现Vue框架中的异步回调队列。

nextTick不仅仅时Vue内部的异步队列调用方法，同时也允许开发者在实际项目中使用这个方法满足实际应用中对DOM更新数据时机的后续逻辑处理。引入异步调用队列，主要有以下几点原因：

* 如果时同步更新，则多次对一个或多个属性赋值，会频繁触发UI和DOM的渲染。
* 由于虚拟DOM的引入，每次状态发生变化以后，状态变化的信号会发送给组件，组件内部使用虚拟DOM计算需要更新的DOM节点，然后对真实的DOM进行更新操作，每次更新状态后的渲染过程需要更多的计算，会消耗时间。

## Vue事件

### 常见事件修饰符

* .stop
* .prevent
* .capture
* .self
* .once



### Vue指令



## Vue组件化

### slot插槽的作用及原理

slot也就是插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽是子组件的一个模板标签元素，这个标签元素是否显示以及如何显示则是由父组件决定的。插槽可以分为三类：

* 默认插槽，又叫做匿名插槽：当插槽没有指定name属性值的时候默认显示的插槽，一个组件只能有一个默认插槽。
* 具名插槽，或者叫做有名插槽。带有name属性的插槽。
* 作用域插槽，是默认插槽和具名插槽的变体。该插槽的不同点在于，子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件传递来的数据来决定如何渲染该插槽。

实现原理：当子组件的vm实例化时，获取到父组件传入的插槽标签中的内容，然后存放在子组件vue实例的`vm.$slot`中，具体的插槽有默认插槽`vm.$slot.defalut`具名插槽`vm.$slot.xxx`当组件执行渲染函数时，遇到插槽的标签，则会使用实例的`$slot`中的内容替换，此时可以为插槽传递数据，如果存在数据，则称该插槽为作用域插槽。

### keep-alive组件

keep-alive是vue的一个内置组件，如果我们需要在组件切换时，保存某些组件的状态防止多次渲染，就可以使用keep-alive组件包裹需要保存的组件。keep-alive组件有三个重要属性：

* include 字符串或者正则表达式，任何名称匹配的组件都会被缓存
* exclude 字符串或者正则表达式，任何名称匹配的组件都不会被缓存
* max：最多可以缓存多少组件实例

主要流程

1. 判断组件名称，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存
2. 获取组件实例的key，否则生成一个
3. 如果缓存的对象存在，则直接获取其组件实例的vnode，不存在则添加到缓存中
4. 当缓存组件数量超过max值时，则清除最先缓存的组件

//todo

### mixin

* Mixin时我们能够为组件编写可插拔和可重用的功能
* 如果需要在多个组件之间重用组件选项，如生命周期、方法，则可以将其编写为mixin，在组件中引用

### 如何保存页面的状态

在Vue中，页面是由多个Vue组件构成的，我们要保存页面的状态，也就是要保存当前页面中组件的状态。我们分情况讨论，当组件是否被卸载时。

#### 组件被卸载

1. 将状态存储在浏览器本地存储中，如LocalStorage或SessionStorage中
2. 通过路由将该组件数据传递下去



#### 组件不会被卸载



### 子组件可以直接改变父组件的数据吗？



## Vue生命周期

### Vue声明周期介绍

Vue从开始创建、初始化数据、编译模板、挂载Dom、渲染更新和卸载一整个流程，称为Vue的声明周期。具体可以分为以下几个部分。

1. beforeCreate（创建之前）：在Vue实例真正创建完成之前，在这个时刻，数据绑定和初始化事件还没有开始，此时绑定数据不存在响应式，事件event和侦听器watcher都没有被设置，这个阶段无法访问到Vue实例中的data、computed、watch、method等属性。
2. created（创建之后）：此时实例创建完成，data、computed、watch、method等属性已经配置完成，但是此时渲染的虚拟DOM还没有挂载到真实DOM中，无法通过Vue实例访问到 DOM 根节点 `$el`
3. beforeMount（挂载之前）：在挂载之前，实例开始调用render函数进行虚拟DOM渲染，开始编译Template模板中的文档，将变量替换为实例data中的数据，然后生成虚拟DOM文档，但是此时的文档并没有挂载到页面中
4. mounted（挂载完成）：可以通过Vue实例访问到 DOM 根节点 `$el`，文档已经被挂载到页面中，并完成页面的渲染，通常页面在这时进行ajax交互
5. beforeUpdate（更新前）：在数据发生变化时，会触发更新时生命周期，在页面更新之前，会生成一份新的虚拟DOM，通过对比新旧虚拟DOM找出变化的部分。虽然响应式数据已经被更新，但是还没有将真实的DOM渲染到页面上。
6. updated（更新后）：页面更新之后，真实的DOM已经被渲染到页面上。
7. beforeDestory（销毁之前）：在Vue实例销毁之前，Vue有一个钩子函数beforeDestory可以进行一些垃圾回收和变量清理操作
8. destoryed（销毁之后）：Vue实例解除数据、事件的绑定，移除所有的监听器，销毁子实例。

但有一个组件比较特殊，[Keep-Alive组件]()，增加了两个声明周期，分别是激活时（activated）、停用时（deactivated）。被Keep-Alive组件包裹的组件在切换后不会被销毁，而是缓存在内存中，执行deactivated钩子函数。在切换回来时会执行activated钩子函数。该组件无法触发beforeDestory、destoryed生命周期中的钩子函数

### created和mounted的区别

- created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
- mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

### 一般在哪个生命周期请求异步数据

我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面加载时间，用户体验更好；
- 在服务端渲染时不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。

### 声明周期中Vue 子组件和父组件执行顺序

**加载渲染过程中：**在父组件准备挂载时子组件开始创建。在子组件挂载结束后，父组件才会挂载结束。

**更新过程中：**父组件先开始更新，随后是子组件，子组件最先更新完毕，父组件最后更新完成。

## Vue高级

### 单页面应用和多页面应用的区别

单页面应用（Single Page Web Application，SPA）指的是只有一个主页面的应用，一开始只需要加载一次js、css等相关资源，所有内容都包含在主页面，对每个功能模块组件化，单页应用跳转，切换组件仅仅刷新局部资源。

多页面应用（Multi-Page Application，MPA）指的是具有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。

| 对比项   | SPA                                                          | MPA                                               |
| -------- | ------------------------------------------------------------ | ------------------------------------------------- |
| 结构     | 由一个主页面和多个组件组成                                   | 许多完整的页面构成                                |
| 体验     | 页面切换快，体验佳；但是当初次加载文件过多时，速度较慢，需要针对性调优 | 页面切换慢，体验差                                |
| 资源文件 | 组件公用资源只需加载一次                                     | 每个页面都需要自己加载公用资源                    |
| 适用场景 | 对体验度和流畅度有较高要求的应用，不利于搜索引擎优化         | 适合对搜索引擎优化要求较高的应用                  |
| 过渡动画 | Vue提供了transition的封装组件，容易实现                      | 很难实现                                          |
| 内容更新 | 局部更新                                                     | 整体HTML的切换                                    |
| 路由模式 | 可以使用hash和history                                        | 链接跳转                                          |
| 数据传递 | 通过全局变量                                                 | cookie、localStorage等缓存方案，URL参数，调用接口 |
| 相关成本 | 前期开发成本搞，后期维护方便                                 | 前期开发成本低，后期维护麻烦                      |

### 单页面应用的优缺点

优点：

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

### 服务端渲染

服务端渲染也就是Server-side rendering (SSR)，将Vue本应该在客户端渲染标签的工作放在服务端完成，然后将HTML文档直接返回给客户端。这样做有优点也有缺点。

优点是：

* 更好的搜索引擎优化
* 首屏加载速度更快

缺点：

* 开发条件受到限制。Vue生命周期中可使用的钩子数量变少
* 当需要一些外部扩展库时需要特殊处理，服务端渲染需要处于Node.js运行环境
* 更多服务端负载

### 性能优化方法

简单性能优化

1. [路由懒加载]()
2. [keep-alive]()组件缓存页面
3. 使用v-show服用DOM
4. 在v-for遍历时避免使用v-if，判断会增加渲染时间，在数据量大时，会拖慢页面反应速度
5. 长列表性能优化，只渲染少部分区域的内容，对不会有任何改变的数据放弃响应化

进一步性能优化，分为4个不同的方面

#### 编码阶段

* 尽量减少不必要的响应式数据，响应式数据会添加getter和setter以及对应的侦听器，性能相比非响应数据要差
* 如果需要通过遍历v-for给每项元素绑定事件时使用[事件代理]()
* 单页面应用中应用keep-alive缓存组件，减少组件创建和销毁性能消耗
* 使用v-if代替v-show
* 保证元素的key值唯一
* 使用路由懒加载以及异步组件
* 使用函数防抖和节流
* 按需导入第三方模块
* 长列表性能优化，只渲染少部分区域的内容
* 图片懒加载

#### SEO（Search Engine Optimization）搜索引擎优化

* 预渲染
* 服务端渲染

#### 打包优化

* 压缩代码
* 通过Tree Shaking，作用域提升
* 使用cdn加载第三方模块
* 多线程打包Happypack？
* splitChunks抽离公共文件？
* sourceMap优化？

#### 用户体验

* 骨架屏
* PWA（Progressive Web Apps）
* 使用缓存优化

### 设计原则的理解





## 虚拟DOM

### 虚拟DOM的理解

首先我们需要了解DOM，指的是文档对象模型，它将一个HTML文档当作一个节点树，其中的每个节点代表一个HTML元素。DOM本身是一个编程接口，能够允许我们从文档中创建、更改和删除元素，也可以在元素中添加事件。

而虚拟DOM（Virtual Document Object Model）是一个JavaScript对象，是利用JavaScript对象来表示真实的DOM结构。虚拟DOM是对真实DOM的抽象，相对于真实的DOM更加轻量，设计的目的就是为了更好的跨平台渲染。比如在Node.js中就没有DOM对象，如果希望实现服务端渲染，就需要通过虚拟DOM模拟真实DOM，在代码渲染到页面之前，通过该对象描述真实的DOM结构，最终渲染到页面上。在每次数据发生变化之前，虚拟DOM会缓存一份，在数据变化时，会生成一份新的虚拟DOM，Vue内部封装了一个diff算法，来比较新旧两份虚拟DOM的区别，从而渲染数据改变的那一部分。

利用虚拟DOM配合不同的渲染工具，使得跨平台渲染成为可能。利用事务处理机制，将多次修改DOM的结果一次性更新到页面上，能够有效减少页面渲染的次数，减少修改DOM浏览器重绘重排的次数，从而提高渲染性能。

### 虚拟DOM的解析过程

1. 首先对文档DOM树结构进行解析，将其用JavaScript对象表示并保存，最后在将DOM片段插入文档中
2. 当页面状态发生改变时，我们需要对页面的DOM结构进行调整，首先根据变更的状态，重新构建一颗对象树，和旧的进行比较，记录两者之间的差异
3. 将有差异的地方更新到真正的DOM树中，随后页面重新渲染。

### 为什么要使用虚拟DOM

1. 保证性能下限，在不进行手动优化的情况下，提供良好的性能。
2. 方便跨平台渲染

在首次渲染大量的DOM对象时，多了虚拟DOM的计算会比没有要慢。

### DIFF算法

diff算法是Vue的核心算法，用来比较新旧两份虚拟DOM的区别。分为以下几个步骤：

1. 首先，对比节点本身，判断是否是同一节点，如果不为相同节点，则重新创建新的节点替换该节点
2. 如果是相同的节点，则对该节点的子节点进行处理，先判断一方有而另一方没有子节点的情况，如新的节点没有子节点，而旧的有，则替换旧节点
3. 比较如果都有子节点，则更新其子节点，从而判断如何对这些新老节点的子节点操作
4. 匹配时，会找到相同的子节点，然后递归的进行比较

### Vue遍历中key的作用（待补充）



## Vue-Router

### 如何实现路由懒加载

1. 在定义路由规则时通过箭头函数和import动态加载该组件
2. 使用箭头函数+require动态加载
3. 使用webpack的require.ensure技术，实现按需加载。 

### 路由的hash和history模式的区别

#### hash模式



#### history模式

## Pinia

