# 1.递归算法

## 1.1 算法策略

递归算法是一种直接或者间接调用自身函数或者方法的算法，实质是把问题分解为规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。

## 1.2 适用场景

* 数据定义是按递归定义的（斐波那契数列）
* 问题解法按递归算法实现（回溯）
* 数据的结构形式是按照递归定义的（树的遍历，图的搜索）

## 1.3 解题策略

1. 明确函数的输入和输出，功能是什么，要完成什么事
2. 寻找递归结束的条件，把结果返回
3. 明确递归关系式，怎么通过各种递归调用来组合解决当前问题

## 1.4 例子——DOM树

### 第一步：明确函数的输入和输出

输入：DOM根节点，要寻找的结点id

输出：返回满足id="sisteran"的子节点

```java
Node getElementById(Node node, Long id);
```

### 第二步：寻找递归结束的条件

从根节点往下，对所有子节点递归查找他们的子节点，一层一层往下，对于正在查找的那个子节点：

* 如果该节点id符合查找条件，则返回当前结点
* 如果已经到了叶子结点还没有找到则返回null

```java
Node getElementById(Node node, Long id){
    if(!node) return null;
    if(node.id == id) return node;
}
```

### 第三步：明确递归关系式

当前结点不符合条件时，递归的查找他的每一个结点

```java
Node getElementById(Node node, Long id){
    if(!node) return null;
    if(node.id == id) return node;
    for(int i=0; i< node.childNodes.length(); i++){
        Node found = getElementById(node.childNodes[i], id);
        if(found) return found;
    }
    return null;
}
```

### 非递归遍历的求法

```java
Node getByElementById(Node node, Long id){
    while(node){
        if(node.id == id) return node;
        // 负责查找下一个结点
        node = nextElement(node);
    }
    return null;
}
//深度优先遍历
Node nextElement(Node node){
    if(node.children.length()){
        return node.children[0];
    }
    if(node.netElementSibling){
        return node.nextElementSibling;
    }
    while(node.parentNode){
        if(node.parentNode.nextElementSibling){
            return node.parentNode.nextElementSibling;
        }
        node = node.parentNode;
    }
    return null;
}
```

# 2. 分治算法

## 2.1 算法策略

将一个复杂的问题，分成两个或者多个相似的子问题，把子问题分成更小的子问题，直到更小的子问题可以简单的求解，求解子问题，原问题的解就是子问题解的合并。

## 2.2 适用场景

* 原始问题可以分成多个相似的子问题
* 子问题可以很简单的求解
* 原始问题的解时子问题解的合并
* 各个子问题是相互独立的不包含相同的子问题

## 2.3 解题策略

1. 分解，将原问题分解为若干个规模较小相互独立，与原问题形式相同的子问题
2. 解决，解决各个子问题
3. 合并，将各个子问题的解合并为原问题的解

# 3. 贪心算法

## 3.1 算法策略

总是做出当前的最优选择，期望通过局部最优选择获得整体最优选择。

## 3.2 适用场景

如从一百张面值不等的钞票中抽出10张，怎样获得最大价值。我们只需要每次选择剩下的钞票中的最大值，最后就是最优解。

但是贪心算法算出来的也不一定总是最优解，当满足以下条件时：

* 原问题复杂度过高
* 求全局最优解的数学模型难以建立或者计算量过大
* 没有太大必要求出全局最优解

## 3.3 解题策略

1. 首先明确什么是最优解
2. 把问题分成多个步骤，每一步都满足问题的约束，每一步都做出局部最优的选择，选择一旦做出后面遇到任何情况都不可以取消。
3. 叠加所有步骤的最优解，就是全局最优解

## 3.4 例子——活动选择问题

有n个活动需要适用同一个资源，资源在某个时刻只能

# 4. 回溯算法

## 4.1 算法策略

是一种搜索法，试探法，他会在每一步做出选择，一旦发现这个选择无法得到期望的结果就回溯过去，重新做出选择。

## 4.2 适用场景

深度优先搜索、0-1背包问题、正则表达式匹配、八皇后、数独、全排列

# 5. 动态规划

## 5.1 算法策略

动态规划是将复杂问题分解成为小问题求解的策略，与分治算法不同，分治要求各个子问题是相互独立的，但是动态规划的各个子问题是相互关联的

因此动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，这种情况下，分治法会做出很多不必要的工作，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到了一致的问题，从表格中获取即可，所以无需求解每一个子子问题。

## 5.2 适用场景

用于求解最优解问题，如从面额不定的100个硬币中任意选取多个凑成10元，怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够10元。

这个问题可以分成一个个子问题——每次选取硬币，每个子问题又有公共子子问题——选取硬币，子问题之间互相关联——已选取的硬币总金额不能超过10元，边界条件就是最终选取的硬币总金额10元。

## 5.3 解题策略

1. 定义子问题
2. 实现需要反复执行解决的子子问题部分
3. 识别并求解出边界条件

## 5.4 例子——爬楼梯问题

* 爬楼梯问题：需要n阶才能够到达楼顶，每次可以爬1-2个台阶，有多少种不同的方法可以爬到楼顶
* 背包问题：给出一些资源（总量+价值），给定一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的前提下，装入更多的价值
* 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种方案
* 图的全源最短路径：找到从顶点u到顶点v的最短路径
* 最长公共子序列：找出一组序列的最长公共子序列

以爬楼梯问题为例：

### 第一步：定义子问题

用dp[n]来表示迈过第n级台阶的方案数，由于最后一步可能迈两个台阶，也有可能只迈一个台阶，因此第n级台阶的方案数等于第n-1级台阶的方案数加上第n-2级台阶的方案数

### 第二步：实现需要反复执行解决的子子问题部分

```java
dp[n] = dp[n-1] + dp[n-2]
```

### 第三步：识别并求解出边界条件

```java
// 如果台阶数为0，也算是1种
dp[0] = 1
// 台阶数为1，也只有一种方案
dp[1] = 1
```

### 第四步：翻译为代码

```java
int climbStairs(int n){
    int[] dp = [1, 1];
    for(int i = 2; i<= n; i++){
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n];
}
```

这种情况下，时间复杂度和空间复杂度都为O(n)，但是实际上我们只需要保留三个变量就可以了，中间变量在循环中都会丢弃。

```java
int climbStairs(int n){
    int dp0 = 1, dp1 = 1, res = 1;
    for(int i = 2; i<=n; i++){
        res = dp0 + dp1;
        dp1 = res;
        dp0 = dp1;
    }
    return res;
}
```

## 5.5 例子——使用最小花费爬楼梯

数组的每一个索引作为一个阶梯，第i个阶梯对应这一个非负数的体力花费值cost[i]。当你爬上一个阶梯都需要花费对应的体力值，然后可以选择继续爬一个阶梯或者爬两个阶梯。找到达到楼层顶部的最低花费，在开始时，可以选择索引为0或者1的元素作为初始阶梯。

注意到：

* 第i级台阶是第i-1阶台阶的顶部
* 踏上第i级台阶花费cost[i]，如果越过区则不需要花费
* 楼梯的顶部在数组之外

### 第一步：定义子问题

首先子问题是踏上某一个台阶所需要的最低花费，这个最低花费就是到达前两个阶梯的最小体力消耗+本层的体力消耗

如果迈一步踏上第i级台阶，那么就是在第i-1级阶梯的累计体力消耗加上本层消耗：dp[i-1] + cost[i]

如果迈两步踏上第i级台阶，那么就是在第i-2级台阶的累计体力消耗加上本层消耗：dp[i-2] + cost[i]

### 第二步：实现需要反复执行的子子问题部分

```java
dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
```

### 第三步：识别并求出边界条件

刚开始时，如果只有0级台阶，跨过花费为cost[0]，如果有1级台阶，跨过的话有两种情况，分别踏上第0级第1级台阶，直接跨到第一级台阶上。花费min(cost[0] + cost[1], cost[1])

```
dp[0] = cost[0];
dp[1] = Math.min(cost[0] + cost[1], cost[1]);
```

### 第四步：翻译

```java
Integer minCostClimbingStairs(List<Integer> cost){
    List<Integer> dp = new ArrayList<>();
    dp.set(0, cost.get(0));
    dp.set(1, Math.min(cost.get(0) + cost.get(1), cost.get(1)));
    for(int i = 2; i < cost.length(); i++){
       dp.set(i, Math.min(dp[i-2], dp[i-1]) + cost.get(i)); 
    }
    return dp.get(cost.length());
}
```

## 5.5 最大子序和

给定一个整数数组nums，找到一个具有最大和的连续子数组，子数组中最少包含一个元素，返回其最大和。

# 6. 枚举算法

## 6.1 算法策略

将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适



